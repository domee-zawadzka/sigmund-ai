[
  {
    "content": "# Python Tutorials\n\ntitle: Python Tutorials\n\nCongratulations, you're about to learn Python!\n\n[Python](http://www.python.org/) is a widely used programming language that is intuitive and easy to learn. From researchers to independent developers to large companies such as Facebook and DropBox: they all rely on Python. And for good reasons.\n\nThe goal of this website is to provide __free, introductory courses to Python__ with a mix of __tutorials__ and __interactive excercises__. No need to sign up for an account! So let's get started with one of the three courses!\n\n<div width=50%>\n<p><a class='btn btn-success btn-large btn-block' href='%url:basic/introduction%'>\n<b>&#128035; Python basics</b><br />\n8 chapters with interactive mini exercises and review exercises\n</a></p>\n<p><a class='btn btn-info btn-large btn-block' href='%url:numerical/introduction%'>\n<b>&#128202; Data science</b><br />\n6 chapters about data science and numerical Python\n</a>\n</p>\n<p><a class='btn btn-primary btn-large btn-block' href='%url:deep-learning/introduction%'>\n<b>&#128025; Deep learning</b><br />\n4 chapters about deep learning with Keras and TensorFlow\n</a>\n</p>\n</div>\n\nOr take a look at this compilation of video tutorials!\n\n<div width=50%>\n<p><a class='btn btn-success btn-large btn-block' href='%url:video/object-oriented-programming%'>\n<b>&#127916; Video tutorials</b><br />\n4 chapters with 24 videos about various topics related to Python programming\n</a>\n</p>\n</div>",
    "title": "Python Tutorials",
    "url": "https://pythontutorials.eu/index",
    "path": "content/pages/index.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Modules\n\ntitle: Modules\nnext_title: Exceptions\nnext_url: %url:exceptions%\n\n\n<div class=\"learning-goals\" markdown=\"1\">\nModules provide additional functionality. There are thousands of Python modules! Let's see how you can use all that functionality in your code.\n{.summary}\n\nIn this chapter, you will learn\n{.header}\n\n- About the Python standard library\n- How to use the `import` statement to import modules\n\nTest yourself\n{.header}\n\n- Two interactive mini exercises\n- Two review exercises\n</div>\n\n\n[TOC]\n\n\n## The Python standard library\n\nSo far, we've only used functions that are built into Python, and that you can use straight away when you start a Python interpreter. However, you can `import` modules to get additional functionality. Many common modules are included in Python by default so that you don't need to install them\u2014but you do have to `import` them! These modules make up the Python standard library:\n\n- <https://docs.python.org/3/library/index.html>\n\n\n## `import`: importing modules\n\nLet's consider the `random` module:\n\n- <https://docs.python.org/3/library/random.html>\n\nThe `random` module contains many functions for randomization. For example, `random.choice()` takes an iterable, such as a `list`, and returns a single, randomly selected element. To use `random.choice()`, you need to `import` the `random` module.\n\n\n```python\n# Preferred\nimport random\nprime_numbers = [1, 3, 5, 7, 11]\nprint(random.choice(prime_numbers))\n```\n\nIn the example above, you import the entire `random` module and then selectively call `random.choice()`. However, the `import` statement is flexible and allows you to import modules and functions in many different ways. These all have their place, but as a general rule, the `import` method shown above is clearest and therefore preferred.\n\n\n<div class=\"exercise\" id=\"exercise_import\" markdown=\"1\">\n#### Mini exercise\n\nImport the `string` module, and print out [all ASCII letters](https://docs.python.org/3/library/string.html#string.ascii_letters) as defined in this module.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</div>\n</div>\n\nYou can also selectively import the `choice()` function. The downside of this way of importing is that you cannot easily tell anymore that `choice()` is part of the `random` module.\n\n\n```python\n# Not preferred\nfrom random import choice\nprint(choice(prime_numbers))\n```\n\n<div class=\"exercise\" id=\"exercise_import_from\" markdown=\"1\">\n#### Mini exercise\n\nSelectively import the `sample()` function from the `random` module, and the `ascii_letters` attribute of the `string` module. Use these to randomly sample five letters and assign these to a variable called `five_letters`.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_validate\">\nimport random\nimport string\ncorrect = 1\ntry:\n    if random.sample is not sample:\n        correct = 0\n    if string.ascii_letters is not ascii_letters:\n        correct = 0\n    if len(five_letters) != 5:\n        correct = 0\nexcept:\n    correct = 0\n</div>\n</div>\n\n\nYou can also directly import everything from the `random` module: a *wildcard* import. This is generally considered bad practice, because it makes it difficult to tell where a function comes from.\n\n\n```python\n# Not preferred\nfrom random import *\nprint(choice(prime_numbers))\n```\n\nFinally, the `import` statement allows you to rename the imported modules or functions. Again, this is generally not preferred because of potential confusion. Exceptions are libraries such as `numpy` for which an import-and-rename (`import numpy as np`) is so common that it is unlikely to result in confusion.\n\n\n```python\n# Not preferred\nimport random as rnd\nprint(rnd.choice(prime_numbers))\n```\n\n## Installing additional modules with pip\n\nThere are also many modules that are not part of the Python standard library, that is, modules that are not included with Python by default. Fortunately, it's easy to install these additional modules with `pip`, the __P__ackage __I__nstaller for __P__ython. `pip` installs packages from the Python Package Index, or PyPI, which is like an app-store for Python packages. Almost every Python package that exists is available from there:\n\n- <https://pypi.org/>\n\n`pip` is a command-line that is included with Python. If you're using a code editor with a Python environment, such as Rapunzel or Spyder, the easiest to call pip is simply by entering a `pip` command in the Python console. (This works because the code editor recognizes that a `pip` command is not Python code, but rather a call to the `pip` application.)\n\nTo install a package, simply execute `pip install` followed by the name of the package. For example, to install [DataMatrix](%url:datamatrix%), a package for working with tabular data, which you may meet later in the data-science course, run:\n\n```\npip install datamatrix\n```\n\n\n## Review exercises\n\n<div class='exercise no-progress' id='exercise_statistics' markdown=1>\n\n### Some simple statistics\n\nUse the `statistics` module to calculate the mean of all prime numbers below 10.\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:modules%-solution-1) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>\n\n<div class='exercise no-progress' id='exercise_files' markdown=1>\n\n### Files and folders\n\nUse the `os` and `os.path` modules to list the contents of your Downloads folder, and indicate for each item whether it's a file or a folder.\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:modules%-solution-2) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>",
    "title": "Modules",
    "url": "https://pythontutorials.eu/basic/modules",
    "path": "content/pages/basic/modules.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Files and folders: Exercise and Solution\n\ntitle: Files and folders: Exercise and Solution\nnext_title: Files and folders\nnext_url: %url:files-and-folders%\n\n\n## An interactive file browser\n\n### Excercise\n\nYou're going to build an interactive file browser! The program starts by listing all files and folders in the current working directory. The first entry in the list is a special entry that corresponds to the parent folder, called '..' (two dots is the standard way to indicate the parent folder); however, this entry is only available if the working directory isn't the root already! Each entry in the list is numbered, starting from 0. \n\nBy entering a number, the user can select a file or folder. Depending on what kind of file or folder it is, one of three things can happen:\n\n- If the user selects a folder or the '..' entry, the working directory is changed to that folder.\n- If the user selects a text file, the content of that file is printed out.\n- If the user selects a binary file, \u00b7the message '[file name] is not a text file' is printed out\n\nNext, the contents of the working directory (which may have changed) are shown again, and the user is prompted to provide new input, and so on, until the user enters `quit`. If the user enters something other than `quit` or a number that corresponds to an entry in the list, an informative warning message (such as 'Invalid user input') is printed out.\n\nAn interaction could look like this:\n\n~~~\nListing contents of /home/sebastiaan/coding\n0: ..\n1: python\n\n>>> 1\nListing contents of /home/sebastiaan/coding/python\n0: ..\n1: exercise1.py\n2: exercise2.py\n\n>>> quit\n~~~\n\nTips:\n\n- `Path.cwd()` returns the working directory\n- `os.chdir()` changes the working directory\n- Calling `Path.read_text()` on a binary file results in a `UnicodeDecodeError`\n\n\n\n### Solution\n\n~~~python\nimport os\nfrom pathlib import Path\n\nwhile True:\n  # Build a list of files and folders in the working directory.\n  entries = []\n  current_folder = Path.cwd()\n  # If we're not already in the root, the first entry is the parent folder\n  if current_folder.parent != current_folder:\n    entries.append(Path('..'))\n  entries += current_folder.glob('*')\n  # Print a numbered list of files and folders\n  print(f'Listing contents of {current_folder}')\n  for i, path in enumerate(entries):\n    print(f'{i}: {path.name}')\n  # Get user input. Valid input is the word 'quit' or a number that corresponds\n  # to an index in the list of files and folders\n  user_input = input('>>> ')\n  if user_input == 'quit':\n    break\n  try:\n    selection = int(user_input)\n  except ValueError:\n    print('Invalid user input (please enter a number)')\n    continue\n  if selection >= len(entries):\n    print('Invalid user input (invalid number)')\n    continue\n  # If the selected path is a folder, then change the working directory to\n  # that folder\n  selected_path = Path(entries[selection])\n  if selected_path.is_dir():\n    os.chdir(selected_path)\n    continue\n  # Otherwise, try to read the file contents as if they are text. If this fails\n  # print a warning message\n  try:\n    file_contents = selected_path.read_text()\n  except UnicodeDecodeError:\n    print(f'{selected_path.name} is not a text file')\n    continue\n  # Otherwise print the file contents\n  print(file_contents)\n~~~",
    "title": "Files and folders: Exercise and Solution",
    "url": "https://pythontutorials.eu/basic/files-and-folders-solution",
    "path": "content/pages/basic/files-and-folders-solution.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Modules: Exercises and Solutions\n\ntitle: Modules: Exercises and Solutions\nnext_title: Modules\nnext_url: %url:modules%\n\n\n## Files and folders\n\n### Exercise\n\nUse the `os` and `os.path` modules to list the contents of your Downloads folder, and indicate for each item whether it's a file or a folder.\n\n\n\n### Solution\n\n~~~ .python\nimport os\n\ndirname = '/home/sebastiaan/Downloads'\nfor basename in os.listdir(dirname):\n  path = os.path.join(dirname, basename)\n  if os.path.isdir(path):\n    print('folder: {0}'.format(path))\n  else:\n    print('file:   {0}'.format(path))\n~~~\n\n__Output:__\n\n~~~\nfile:   /home/sebastiaan/Downloads/revised_ms.docx\nfolder: /home/sebastiaan/Downloads/.config\nfile:   /home/sebastiaan/Downloads/34-278-1-PB.pdf\n~~~",
    "title": "Modules: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/modules-solution-2",
    "path": "content/pages/basic/modules-solution-2.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Loops: Exercises and Solutions\n\ntitle: Loops: Exercises and Solutions\nnext_title: loops\nnext_url: %url:loops%\n\n\n## Fibonacci\n\n### Exercise\n\nCalculate the [Fibonacci series](https://en.wikipedia.org/wiki/Fibonacci_number) up to 1,000. Print out each Fibonacci number including its position in the series. Like so:\n\n~~~\n0: 1\n1: 1\n2: 2\n3: 3\n4: 5\netc.\n~~~\n\n\n\n### Solution\n\n```python\nprev = 1\ncurr = 1\nprint('0: {0}'.format(prev))\nprint('1: {0}'.format(curr))\ni = 2\nwhile True:\n  prev, curr = curr, prev + curr\n  if curr > 1000:\n    break\n  print('{0}: {1}'.format(i, curr))\n  i += 1\n```",
    "title": "Loops: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/loops-solution-1",
    "path": "content/pages/basic/loops-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Iterables: list, dict, tuple, and set\n\ntitle: Iterables: list, dict, tuple, and set\nnext_title: Loops\nnext_url: %url:loops%\n\n\n<div class=\"learning-goals\" markdown=\"1\">\nIterables are list-like objects that contain other objects. These kinds of objects are used heavily in Python, so let's learn how to work with them!\n{.summary}\n\nIn this chapter, you will learn\n{.header}\n\n- What an iterable object is\n- What indexing is\n- What slicing is\n- About the built-in iterable types: list, dict, tuple, and set\n- How to work with the built-in iterables\n\nTest yourself\n{.header}\n\n- Eight interactive mini exercises\n- Two review exercises\n</div>\n\n\n[TOC]\n\n\n## Iterables, order, and mutability\n\nIn Python, an *iterable* object (or simply an *iterable*) is a collection of elements that you can loop (or *iterate*) through one element at a time. Simply put, an iterable is a list-like (or array-like) object. There are many kinds of iterables, which differ in many ways, including whether they are ordered and mutable:\n\n- An iterable is *ordered* if you can retrieve its elements in a *predictable order*\n- An iterable is *mutable* if you can change which elements it contains\n\nPython has four built-in iterable types: `list`, `dict`, `tuple`, and `set`\n\n\n## list: an ordered, mutable collection of elements\n\nA `list` consists of zero or more other elements in a fixed order. The elements of a `list` can be anything, such a numbers (`int`), strings (`str`), and even other `list`s. Different elements from the same `list` can have different types.\n\nA `list` is defined as a comma-separated list of values between square brackets:\n\n\n```python\nprime_numbers = [1, 3, 5, 7, 11]\nprint(prime_numbers)\nempty_list = []\nprint(empty_list)\n```\n\n<div class=\"exercise\" id=\"exercise_list\" markdown=\"1\">\n#### Mini exercise\n\nPrint a `list` that contains the first three letters of the alphabet as three separate elements.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">['a', 'b', 'c']</div>\n</div>\n\n\n### Getting a single element (indexing)\n\nTo get a single element from a `list`, use the *index* (position) of the element, where `0` is the first element, `1` is the second element, etc. That is, Python uses [zero-based indexing](https://en.wikipedia.org/wiki/Zero-based_numbering). You can also count from the end of the `list` by using a negative index, where `-1` is the last element, `-2`, is the second-to-last element, etc.\n\n\n```python\nprint('First prime number:')\nprint(prime_numbers[0])\nprint('Last prime number (of our list):')\nprint(prime_numbers[-1])\n```\n\n<div class=\"exercise\" id=\"exercise_index\" markdown=\"1\">\n#### Mini exercise\n\nCreate a `list` that contains the first five prime numbers. Print out the second number from this list.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">3</div>\n</div>\n\n### Getting a range of elements (slicing)\n\nYou can also get multiple elements from a `list` by specifying a *slice*.\n\n\n```python\nletters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\nfrom_index = 0\nto_index = 4 # Non-inclusive, so until and including 'd' (at index 3)\nin_steps_of = 3\nprint(letters[from_index:to_index:in_steps_of])\n```\n\nAll the parts of a slice are optional, and fall back to the start of the list (for `from_index`), the end of the list (for `to_index`), and steps of 1. So you can get the first two prime numbers by only specifying the `to_index`, like this:\n\n\n```python\nprint(prime_numbers[:2])\n```\n\nA common way to create a copy of a list to get the *full slice*. (This is equivalent to `list.copy()` in Python 3.)\n\n```python\nmy_copy = prime_numbers[:]\n```\n\n<div class=\"exercise\" id=\"exercise_slice\" markdown=\"1\">\n#### Mini exercise\n\nAgain create a `list` that contains the first five prime numbers. Print out a slice that contains all numbers from this `list` except for the first and the last one.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">[3, 5, 7]</div>\n</div>\n\n### len(): counting the number of elements\n\n`len()` counts how many elements there are in a `list`, or more generally in any iterable that has a length. (Some special iterables have no length, for example because they correspond to an infinite series. However, all iterables that we consider here have a length.)\n\n\n```python\nn = len(prime_numbers)\nprint('We have defined {0} prime numbers'.format(n))\n```\n\n\n### in: checking whether an iterable contains an element\n\nPython has a special operator, `in`, to check whether an element is part of a `list` or another iterable.\n\n\n```python\nif 3 in prime_numbers:\n    print('Three is prime')\n```\n\n<div class=\"exercise\" id=\"exercise_in\" markdown=\"1\">\n#### Mini exercise\n\nAgain create a `list` with the first five prime numbers. Ask the user for input. Convert this input to `int`, and check whether the resulting number is in our list of prime numbers. If it is, print out 'The number is prime', else print out 'The number is not among the first five prime numbers'. When running the code, enter one of the first five prime numbers to solve the exercise.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">The number is prime</div>\n</div>\n\n### Modifying a list\n\nA `list` has several common functions for adding or removing elements:\n\n- `list.append(element)` adds an element to the end\n- `list.insert(index, element)` inserts an element at position `index`\n- `element = list.pop()` removes the last element from the list and returns it. You can also specify an index of an element, in which case this element is removed and returned (instead of the last element).\n\n\n```python\nprime_numbers = []\nprime_numbers.append(1)\nprime_numbers.append(3) # Etc.\nprint(prime_numbers)\n```\n\nFor an overview of `list` functions, see:\n\n- <https://docs.python.org/3.6/tutorial/datastructures.html#more-on-lists>\n\n<div class=\"exercise\" id=\"exercise_pop\" markdown=\"1\">\n#### Mini exercise\n\nAgain create a `list` with the first five prime numbers. Remove the third number from the list, using either `pop()` or `remove()`. Print out the resulting `list`.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">[1, 5, 7, 11]</div>\n</div>\n\n\n## dict: an unordered, mutable collection of key-value pairs\n\nA `dict` consists of zero or more key-value pairs. That is, each element of a `dict` is a combination of a value that serves as a key and that is associated with another value. A `dict` is *unordered*, which means that if you iterate through the elements of a `dict`, you are not guaranteed to get the elements in a particular order. So never rely on the order of a `dict`!\n\nA `dict` supports `len()` and `in`, as described above for `list`s. However, indexing a `dict` works differently from a `list`, as discussed below, and slicing is not supported.\n\nA `dict` is defined as a comma-separated list of key : value mappings between curly braces.\n\n\n```python\nages = {\n    'Jay-Z': 52,          # and counting\n    'Emanuel Macron': 44  # and counting\n}\nprint(ages)\n```\n\n\n### Getting a single element (indexing)\n\nIf you want to get an elements from a `dict`, you do this by specifying a `key`.\n\n\n```python\nage_jayz = ages['Jay-Z']\nprint(f'Jay-Z is {age_jayz} years old')\n```\n\nAlternatively, you can use `dict.get()`, which allows you to specify a default value in case the key is not in the `dict`.\n\n```python\nage_depp = ages.get('Johnny Depp', 'unknown')\nprint(f'Johnny Depp is {age_depp} years old')\n```\n\n<div class=\"exercise\" id=\"exercise_dict\" markdown=\"1\">\n#### Mini exercise\n\nDefine a `dict` of the three [largest cities in the world](https://en.wikipedia.org/wiki/List_of_largest_cities#List), where keys are names and values are population numbers in millions of inhabitants (e.g. 37 for Tokyo). Next, ask the user to enter the name of a city. If the city name is part of the `dict`, print out the population in the following format: 'The population of X is Y million inhabitants'. If the city name is not part of the `dict`, fall back to using 'unknown' for the population value.\n\nWhen running the code, enter 'Tokyo' to solve the exercise.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">The population of Tokyo is 30 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 31 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 32 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 33 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 34 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 35 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 36 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 37 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 38 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 39 million inhabitants</div>\n<div hidden class=\"solution_output\">The population of Tokyo is 40 million inhabitants</div>\n</div>\n\n\n## tuple: an ordered, immutable collection of elements\n\nThe `tuple` is very similar to a `list`. The main difference between the two types is that a `tuple` is *immutable*, which means that a `tuple` cannot be changed after it has been defined; in other words, there are no functions such as `tuple.append()`, `tuple.pop()`, etc. However, you can concatenate two `tuple`s using the `+` operator, in which case you get a new `tuple` that contains the elements of both of the concatenated `tuple`s.\n\nA `tuple` supports indexing, slicing, `len()` and `in`, as described above for `list`s.\n\nA `tuple` is defined as a comma-separated list of values, optionally surrounded by parentheses.\n\n\n```python\nfibonacci = 1, 1, 2, 3, 5\n# Parentheses are optional unless they are required to avoid ambiguity\nfibonacci = (1, 1, 2, 3, 5)\n```\n\n\n<div class=\"exercise\" id=\"exercise_tuple\" markdown=\"1\">\n#### Mini exercise\n\nCreate one `tuple` that contains the first five numbers of the fibonacci series. Create another `tuple` that contains the first five prime numbers. Concatenate the two `tuple`s and print out the result.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">(1, 1, 2, 3, 5, 1, 3, 5, 7, 11)</div>\n<div hidden class=\"solution_output\">(1, 3, 5, 7, 11, 1, 1, 2, 3, 5)</div>\n</div>\n\n## set: an unordered, mutable collection of unique elements\n\nThe `set` is a somewhat unusual type, which you will rarely use unless you're doing mathematical computations. A `set` corresponds to a mathematical set as specified in [set theory](https://en.wikipedia.org/wiki/Set_theory).\n\nA `set` supports `len()` and `in`, as described above for `list`s. However, a `set` does not support indexing or slicing.\n\nA `set` is defined as a comma-separated list of values surrounded by curly braces.\n\n```python\nvowels = {'a', 'e', 'i', 'o', 'u'}\n```\n\nA characteristic feature of `set`s is that each element can occur at most once (duplicates are ignored):\n\n```python\nprint({'a', 'e'} == {'a', 'a', 'e', 'e'})\n```\n\nThe `set` also supports standard operations from set theory:\n\n- The union (`|`) of two sets contains all elements that occur in either or both of the sets\n- The intersection (`&`) of two sets contains all elements that occur in both sets\n\n```python\nvowels_1 = {'a', 'e', 'i'}\nvowels_2 = {'i', 'o', 'u'}\nprint('Union: {0}'.format(vowels_1 | vowels_2))\nprint('Intersection: {0}'.format(vowels_1 & vowels_2))\n```\n\nFor more information, see:\n\n- <https://docs.python.org/3.6/library/stdtypes.html?highlight=set#set>\n\n\n<div class=\"exercise\" id=\"exercise_set\" markdown=\"1\">\n#### Mini exercise\n\nCreate one `set` that contains the first five numbers of the fibonacci series. Create another `set` that contains the first five prime numbers. Print out all numbers that occur in both sets (i.e. the intersection).\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">{1, 3, 5}</div>\n</div>\n\n## Review exercises\n\n<div class='exercise no-progress' id='exercise_fibonacci' markdown=1>\n\n### Fibonacci\n\nDefine a `fibonacci` `list` that corresponds to the [Fibonacci series](https://en.wikipedia.org/wiki/Fibonacci_number) up to 8. Then, use slicing to create two subseries:\n\n- `even_fibonacci`, with all numbers at even indices (0, 2, etc.); and\n- `odd_fibonacci`, with all numbers at odd indices (1, 3, etc.).\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:iterables%-solution-1) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>\n\n<div class='exercise no-progress' id='exercise_artists' markdown=1>\n\n### Best-selling artists\n\nDefine an `artists` `dict` with the names of the [four best-selling music artists](https://en.wikipedia.org/wiki/List_of_best-selling_music_artists) as keys, and their claimed sales as values:\n\n1. The Beatles with 600 million sales\n2. Elvis Presley with 600 million sales\n3. Michael Jackson with 350 million sales\n4. Madonna with 300 million sales\n\nThen ask the user to enter the name of an artist. Look up the number of sales of this artist, falling back to 'unknown' if the artists is not in the `dict`, and print out the result.\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:iterables%-solution-2) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>",
    "title": "Iterables: list, dict, tuple, and set",
    "url": "https://pythontutorials.eu/basic/iterables",
    "path": "content/pages/basic/iterables.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Exceptions: Exercises and Solutions\n\ntitle: Exceptions: Exercises and Solutions\nnext_title: Exceptions\nnext_url: %url:exceptions%\n\n\n## An interactive calculator\n\n### Exercise\n\nYou're going to write an interactive calculator! User input is assumed to be a formula that consist of a number, an operator (at least `+` and `-`), and another number, separated by white space (e.g. `1 + 1`). Split user input using [`str.split()`](https://docs.python.org/3/library/stdtypes.html#str.split), and check whether the resulting `list` is valid:\n\n- If the input does not consist of 3 elements, raise a `FormulaError`, which is a custom `Exception`.\n- Try to convert the first and third input to a `float` (like so: `float_value = float(str_value)`). Catch any `ValueError` that occurs, and instead raise a `FormulaError`\n- If the second input is not `'+'` or `'-'`, again raise a `FormulaError`\n\nIf the input is valid, perform the calculation and print out the result. The user is then prompted to provide new input, and so on, until the user enters `quit`.\n\nAn interaction could look like this:\n\n~~~\n>>> 1 + 1\n2.0\n>>> 3.2 - 1.5\n1.7000000000000002\n>>> quit\n~~~\n\n\n\n### Solution\n\n~~~ .python\nclass FormulaError(Exception): pass\n\n\ndef parse_input(user_input):\n\n  input_list = user_input.split()\n  if len(input_list) != 3:\n    raise FormulaError('Input does not consist of three elements')\n  n1, op, n2 = input_list\n  try:\n    n1 = float(n1)\n    n2 = float(n2)\n  except ValueError:\n    raise FormulaError('The first and third input value must be numbers')\n  return n1, op, n2\n\n\ndef calculate(n1, op, n2):\n\n  if op == '+':\n    return n1 + n2\n  if op == '-':\n    return n1 - n2\n  if op == '*':\n    return n1 * n2\n  if op == '/':\n    return n1 / n2\n  raise FormulaError('{0} is not a valid operator'.format(op))\n\n\nwhile True:\n  user_input = input('>>> ')\n  if user_input == 'quit':\n    break\n  n1, op, n2 = parse_input(user_input)\n  result = calculate(n1, op, n2)\n  print(result)\n~~~\n\n__Output:__\n\n~~~\n>>> 1 + 1\n2.0\n>>> 3.2 - 1.5\n1.7000000000000002\n>>> quit\n~~~",
    "title": "Exceptions: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/exceptions-solution",
    "path": "content/pages/basic/exceptions-solution.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Basic Syntax\n\ntitle: Basic Syntax\nnext_title: Iterables\nnext_url: %url:iterables%\n\n\n<div class=\"learning-goals\" markdown=\"1\">\nThe syntax of a programming language such as Python is like the grammar of a regular language. Let's start by learning the most important rules of the language!\n{.summary}\n\nIn this chapter, you will learn\n{.header}\n\n- The rules (syntax) of the Python language\n- How to get user input and print output\n- How to add code comments\n- How to work with variables\n- The most common variable types\n- How to use if statements\n\nTest yourself\n{.header}\n\n- Eight interactive mini exercises\n- One review exercise\n</div>\n\n\n[TOC]\n\n\n## Input and output\n\nProgramming is about communication between the user (or users) and the computer. Therefore, the computer needs to be able to communicate to you, that is, send *output*. And you need to be able to communicate to the computer, that is, provide *input*.\n\n\n### print()\n\nYou can print a message to the *standard output* with the `print()` function. (`print()` accepts all the variable types that we will discuss below.)\n\n```python\nprint('Hello world!')\nprint(10)\nprint(True)\nprint(None)\n```\n\nThe *standard output* is the default output channel of your program. If you're using Python from a terminal, then whatever goes to the standard output appears in the terminal; if you're using Python from within Rapunzel or Spyder, then whatever goes to the standard output appears in the IPython console; if you're using Python from within a Jupyter Notebook, then whatever goes to the standard output appears in the notebook; an in the interactive mini exercises, whatever goes to the standard output appears below the exercise.\n\nBut you generally don't have to worry about this: Your output will appear where you expect it to appear.\n\n\n<div class=\"exercise\" id=\"exercise_print\" markdown=\"1\">\n#### Mini exercise\n\nPrint \"Learning Python is fun!\" to the standard output. (Type your solution below and click Run to execute. Your solution is checked automatically.)\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">Learning Python is fun!</div>\n</div>\n\n\n### input()\n\nYou can read text from the standard input with the `input()` function. (This returns a `str` that you can assign to a variable, as we will discuss below.)\n\n~~~ .python\nuser_input = input('>>> ')\nprint(user_input)\n~~~\n\n__Output:__\n\n~~~ .bash\n>>> Hello world!\nHello world!\n~~~\n\nThe *standard input* is the default input channel of your program. If you're using Python in an interactive environment, such as this website, Rapunzel, Spyder, or a Jupyter Notebook, then the user is prompted to provide input whenever the program tries to read from the standard input.\n\nAgain, you generally don't have to worry about this: User input will be handled as you'd expect it to.\n\n<div class=\"exercise\" id=\"exercise_input\" markdown=\"1\">\n#### Mini exercise\n\nAsk the user for input. Print out the result. When running the code, enter 42 as input to solve the exercise.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">42</div>\n</div>\n\n\n## Comments\n\nA line that starts with a `#` is a *comment*. Comments only serve to document your code. It is good practice to comment code that is not self-explanatory. However, in many cases, well-written code is self-explanatory, and adding (too many) comments will only make it less clear.\n\n\n```python\n# This is a comment!\n```\n\n\n## Variable assignment\n\nPython is *dynamically typed*, which means that you not need to explicitly indicate whether a variable is a number, a string, or something else. That doesn't mean that there are no variable types: There are, but the type of a variable is determined implicitly by the value that you assign (`=`) to it. (We will meet different variable types below.)\n\n\n```python\na = 1\nprint(a)\n```\n\nYou can also assign a single value to multiple variables in a single statement. And you can even assign multiple values to multiple variables in a single statement:\n\n\n```python\nb = c = 2 # b = 2; c = 2\nd, e = 3, 4 # d = 3; e = 4\n```\n\nIt is good practice to use variable names that are descriptive but not too long. For example, if a variable contains someone's age, the name `age` is preferable to `a` or (even worse) `x`. Variable names should be lowercase with words optionally separated by underscores, `like_this`. (Naming conventions such as this are described in the [PEP8] style guideline.)\n\n<div class=\"exercise\" id=\"exercise_assignment\" markdown=\"1\">\n#### Mini exercise\nAssign the value 'python' to a variable with the name `my_favorite_language`.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_validate\">\ntry:\n    correct = my_favorite_language.lower() == 'python'\nexcept:\n    correct = 0\n</div>\n</div>\n\n\n## Constants\n\nA *constant* is a computer-science term for a variable that has a fixed value. In Python, real constants don't exist, because you can always change a variable. However, to indicate that a variable should be treated *as if* it were a constant, you can capitalize its name, `LIKE_THIS`.\n\n\n```python\n# PI should be treated as a constant\nPI = 3.14\n```\n\n\n## Common variable types\n\n\n### bool: True or False\n\nA `bool` (from *Boolean*) is a variable type with only two values: `True` or `False`. It is used for logical operations including, as you will see below, `if` statements. Many operations, such as `>`, `==`, and `!=`, result in a `bool`. There is also a special set of Boolean operations: `and`, `or`, and `not`\n\n\n```python\nprint(4 > 3)\nprint(3 > 4)\nprint(3 == 4) # The equality operator is a double equals sign!\nprint(4 > 3 or 3 > 4)\nprint(4 > 3 and not 3 > 4)\n```\n\n<div class=\"exercise\" id=\"exercise_bool\" markdown=\"1\">\n#### Mini exercise\n\nRead two numbers from the standard input. Check whether the two numbers are the same and print out the resulting `bool` value. When running the code, enter two identical numbers to solve the exercise.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">True</div>\n</div>\n\n\n### str: text strings\n\nText strings (`str`) are indicated by putting text between single (`'`) or double (`\"`) quotes. You can specify strings spanning multiple lines with triplets of single (`'''`) or double (`\"\"\"`) quotes:\n\n\n```python\na_str = 'some text'\nanother_str = \"some text\"\na_multiline_str = '''Line 1\nLine 2'''\nanother_multiline_str = \"\"\"Line 1\nLine 2\"\"\"\n```\n\nIf you want to include quotes as characters in a string, you can 'escape' them using an `\\` to indicate that the character is part of the string.\n\n```python\nan_escaped_str = 'You can escape \\'quotes\\' to make them part of the string'\n```\n\nYou often want to print out a string of text with some values inserted into it, and there are several ways to do this. You can:\n\n- Concatenate (`+`) strings.\n- Use the `%` string-formatting operator, which trats the string as a template and inserts values into it.\n- Use `str.format()`, which similarly treats the string as a template, and inserts values into it.\n- Use *f-strings* (formatted string literals), which are prefixed with an `f`, and which allow you to embed variables directly in the string.\n\n\n```python\nname = 'Audrey Tautou'\nprint('My name is ' + name)\nprint('My name is %s' % name)\nprint('My name is {0}'.format(name))\nprint(f'My name is {name}')  # This is what we will use\n```\n\nIn addition to `str.format()`, `str` objects support many more functions. For example, the `str.startswith()` function checks whether the first part of a `str` is equal to another `str`.\n\n```python\nprint(another_str.startswith('some'))\n```\n\nFor a complete list of `str` functions, see:\n\n- <https://docs.python.org/3/library/stdtypes.html#string-methods>\n\n\n<div class=\"exercise\" id=\"exercise_str\" markdown=\"1\">\n#### Mini exercise\n\nThe `str.lower()` function turns all letters of a string into lowercase. Take a string that contains uppercase letters (e.g. 'some UPPERCASE LETTERS'), turn it into lowercase, and assign the resulting string to a variable called `my_lowercase_str`.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_validate\">\ntry:\n    correct = my_lowercase_str.islower()\nexcept:\n    correct = 0\n</div>\n</div>\n\n### None: a special kind of nothing\n\n`None` is a special kind of value that is a type of its own (`NoneType`). Its main function is to indicate that a value is missing. To check whether a value is `None`, the special `is` operator is often used (and considered more elegant) instead of the regular `==` comparison.\n\n```python\nage_depp = None\nif age_depp is None:\n    print('Johnny Depp is ageless')\n```\n\n\n### int and float: numbers\n\nThe two main numeric types are:\n\n- `int` for integer numbers (without decimals)\n- `float` for floating-point numbers (with decimals)\n\nPython automatically determines whether a value is an `int` or a `float`.\n\n```python\nmy_int = 7\nmy_first_float = 3.14\nmy_second_float = 7. # The decimal point indicates that this should be a float\n```\n\nYou can perform [all standard mathematical operations](https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex), such as `+` and `*`. You can determine the order in which operations should be evaluated with parentheses.\n\n```python\nmul_add = 2 * 3 + 4\nadd_mul = 2 * (3 + 4)\n\n# Print out some information about the numbers\nprint('First multiply then add: {0}'.format(mul_add))\nprint('First add then multiply: {0}'.format(add_mul))\n```\n\nThe `float` type has two special values:\n\n- `nan` is *not a number* and is generally used to indicate missing data in numeric computation. It is conceptually similar to `None`, with two important differences: `nan` is the only value that is unequal to itself (whereas `None` is equal to itself), and `nan` can be used in mathematical operations (whereas `None` cannot).\n-  `inf` is used to express infinite numbers. You will rarely encounter `inf`, unless you're doing specific kinds of mathematical computations.\n\n<div class=\"exercise\" id=\"exercise_power\" markdown=\"1\">\n#### Mini exercise\n\nThe `**` operator is used for exponentiation (i.e. 3 raised to the power of 2 equals 9: `3 ** 2 == 9`). To get the square root of a number, you can raise the number to the power .5. Determine the square root of 9 and print it out.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">3.0</div>\n</div>\n\n\n## Converting to float, int, or str\n\nTo convert a variable to a `float`, `int`, or `str`, you can use the corresponding `float()`, `int()`, and `str()` functions. A common use case is when you use `input()` to get a number from the user: `input()` returns a `str`, and you need to use `int()` or `float()` to convert the input to a number.\n\n~~~python\nage = input('How old are you? ')\nage = int(age)\nif age >= 18:\n    print('You are 18 years or older')\nelse:\n    print('You are younger than 18')\n~~~\n\n__Output:__\n\n~~~bash\nHow old are you? 35\nYou are 18 years or older\n~~~\n\nConverting values to another type is dangerous! If you try to convert the value 'this is not a number' to an `int`, you will get an error message, a so-called `Exception`. We discuss how to deal with `Exception`s [later](%url:exceptions%)\n\n```python\n# should-raise\nage = int('this is not a number')\n```\n\nIf you're unsure what type a variable has, you can check with `type()`:\n\n```python\nint_like_str = '10'\nvar_type = type(int_like_str)\nprint('int_like_str is a {var_type}')\n```\n\n<div class=\"exercise\" id=\"exercise_convert\" markdown=\"1\">\n#### Mini exercise\n\nRead two values from the standard input. Convert them to `float`, add them up, and print out the result. To solve the exercise, run the code and enter the numbers 1.5 and 2 so that the sum is 3.5.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">3.5</div>\n</div>\n\n## If statements\n\nAn `if` statement is the most basic form of flow control. It allows you to check whether some condition is `True`, and if so do something. If the condition is `False`, either nothing is done (if there is no `else` block), or something `else` is done. If multiple conditions are checked after each other, you can use the `elif` shorthand, which stands for `else if`:\n\n```python\n# Without else\nif 2 * 2 == 4:\n    print('Two times to equals four')\n# With else\nif 1 * 1 == 2:\n    print('This is not printed')\nelse:\n    print('One times one does not equal two')\n# With elif\nif 3 * 3 == 8:\n    print('This is not printed')\nelif 3 * 3 == 9:\n    print('Three times three equals nine')\nelse:\n    print('This is not printed')\n```\n\nHere we also see an important aspect of Python syntax: colons and indentation. The `if`, `elif`, and `else` statements are followed by a colon (`:`). This indicates that a block of code will follow that is indented, typically by four spaces (as prescribed by [PEP8]) or a single tab. (But never mix different indentation styles in the same code!) The block ends when the indentation ends. Unlike many other programming languages, Python does not use curly braces or other ways to explicitly indicate the start and end of a block: blocks are defined entirely through indentation.\n\n\n<div class=\"exercise\" id=\"exercise_if\" markdown=\"1\">\n#### Mini exercise\n\nAsk the user to guess your age! Read a value from the standard input. Convert it to `int` and check whether it matches your current age. If so, print out 'You guessed correctly!' otherwise print out 'You guessed incorrectly!'. To solve the exercise, run the code and enter your current age.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">You guessed correctly!</div>\n</div>\n\n## Review exercise\n\n<div class='exercise no-progress' id='exercise_pythagoras' markdown=1>\n\n### Pythagoras\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Pythagorean.svg/390px-Pythagorean.svg.png)\n\nImagine a right triangle like the one above and:\n\n- Read a number from the standard input and assign it to `a`\n- Read another number from the standard input and assign it to `b`\n- Use Pythagoras theorem to determine the value of the long side `c`\n- Use string formatting to print out the length of the long side\n- If `c` is larger than `PI` (a constant), also print out: *And this is longer than PI*\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:syntax%-solution) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>\n\n[PEP8]: PEP8)[https://www.python.org/dev/peps/pep-0008/",
    "title": "Basic Syntax",
    "url": "https://pythontutorials.eu/basic/syntax",
    "path": "content/pages/basic/syntax.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Introduction to Python\n\ntitle: Introduction to Python\nnext_title: Syntax\nnext_url: %url:syntax%\n\n\nPython is a widely used programming language that is intuitive and easy to learn. From researchers to independent developers to large companies such as Facebook and DropBox: they all rely on Python. And for good reasons!\n\nIn this course, which consists of eight chapters, you will learn how to program in Python! You will start with the syntax, which are the rules of grammar for a programming language, and from there work your way towards more advanced features of the language. At the end of this course, you will have a solid understanding of Python, and you will be ready to apply that understanding to specific topics, such as software development and data science!\n\n\n<div class=\"learning-goals\" markdown=\"1\">\n\nIn this course, you will learn\n{.header}\n\n- The rules (syntax) of the Python language\n- How to structure your code with loops and functions\n- How to import modules\n- How to handle errors in your code\n- How to work with files and folders\n\n</div>\n\n\n[TOC]\n\n\n%--\nfigure:\n id: FigSnake\n source: python-teacher.png\n caption: Your friendly Python teacher\n--%\n\n\n## Installing and using Python\n\nLet's start by getting you set up, That is, let's see how you can install and use Python, and which version of Python you should use.\n\n\n## Python 2 or 3?\n\nThere are two main versions of Python: 2 and 3. The recommended version is Python 3, which is newer and actively maintained. Python 3 has many secondary versions, such as Python 3.10. For the purpose of this course, any recent version of Python 3 will do.\n\nPython 2 is still used occasionally, but only because certain Python libraries have not yet been updated to be compatible with Python 3. We will not use Python 2 in this course.\n\n\n## Interactive mini exercises in the browser\n\nMost chapters in this course contain interactive mini exercises. These consist of a problem to solve, and a small editor in which you can enter your solution in the form of Python code. You can click the Run button to execute your code, and the output appears in a box below. In most cases, your solution will be checked automatically.\n\nTry it!\n\n<div class=\"exercise\" id=\"exercise_get_started\" markdown=\"1\">\n#### Mini exercise\n\nClick on the Run button to execute the code and solve this mini exercise!\n\n<textarea class=\"code\">\nprint('Welcome to PythonTutorials.eu!')\n</textarea>\n<div hidden class=\"solution_output\">Welcome to PythonTutorials.eu!</div>\n</div>\n\n\n## Code editors for Python\n\nThe mini exercises on this website are a convenient way to practice your Python skills. However, they are not suitable for real-life programming. Therefore, if you want to use Python for real-life programming, you will need a code editor with a Python environment, such as Rapunzel or Spyder.\n\n\n### Rapunzel\n\nRapunzel is a free code editor focused on numerical computing with Python. You can also download it as a standalone application from here (it is also included with [OpenSesame](https://osdoc.cogsci.nl)):\n\n- <https://rapunzel.cogsci.nl/>\n\nIn Rapunzel, create an empty document (`Ctrl+N`) and enter the code `print('Hello world!')` in the editor window. Next, press `F9` to execute (%FigRapunzel). This will execute this line of code in the so-called IPython Console, which by default is on the bottom of the window. You can also type directly into this console.\n\n\n\n%--\nfigure:\n id: FigRapunzel\n source: rapunzel.png\n caption: |\n  Printing 'Hello world' to the IPython console in Rapunzel.\n--%\n\n\n\n### Spyder / Anaconda\n\nAnaconda is a Python distribution that comes with many useful packages pre-installed. Notably, it comes with [Spyder](https://www.spyder-ide.org/) pre-installed, which is another popular code editor for Python.\n\n1. Visit <http://anaconda.org/>, click on *Download Anaconda*, and download the 64 bit version for Python 3.\n2. Once the `.exe` installer has been downloaded, launch it and follow the steps to install Anaconda on your system. The default installation settings are generally fine.\n3. Now launch Spyder, which has been installed as part of Anaconda.\n\nIn Spyder, enter the code `print('Hello world!')` in the editor window, select it and press `F9` to execute (%FigSpyder). This will execute this line of code in the so-called IPython Console, which by default is on the bottom-right of the window. You can also type directly into this console.\n\n%--\nfigure:\n id: FigSpyder\n source: spyder.png\n caption: |\n  Printing 'Hello world' to the IPython console in Spyder.\n--%\n\n\n## Course overview\n\nAll set up? Then let's get started! This course consists of eight chapters. Each chapter builds on the previous chapters, so it is recommended to follow the chapters in order.\n\n1. Introduction to Python (this chapter)\n2. [Syntax](%link:syntax%)\n3. [Iterables: list, dict, and tuple](%link:iterables%)\n4. [Loops: for and while](%link:loops%)\n5. [Functions](%link:functions%)\n6. [Modules](%link:modules%)\n7. [Exceptions: error handling](%link:exceptions%)\n8. [Files and folders](%link:files-and-folders%)",
    "title": "Introduction to Python",
    "url": "https://pythontutorials.eu/basic/introduction",
    "path": "content/pages/basic/introduction.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Loops: for and while\n\ntitle: Loops: for and while\nnext_title: Functions\nnext_url: %url:functions%\n\n\n<div class=\"learning-goals\" markdown=\"1\">\nLoops are a way to repeat blocks of code. Loops are a crucial part of programming, so let's see how they work!\n{.summary}\n\nIn this chapter, you will learn\n{.header}\n\n- What a for loop is\n- What a while loop is\n- How to use the continue keyword\n- How to use the break keyword\n- About useful functions for working with loops\n\nTest yourself\n{.header}\n\n- Seven interactive mini exercises\n- Two review exercises\n</div>\n\n\n[TOC]\n\n\n## The for loop\n\nA `for` loop executes a code block for each element in an iterable, such as a `list`, `tuple`, or `set`. Analogous to the `if` statement, the `for` statement ends with a colon, and the to-be-looped code block is defined by indentation:\n\n\n```python\nprime_numbers = [1, 3, 5, 7, 11]\nfor prime in prime_numbers:\n    # This is inside the loop because it is indented\n    print(prime)\n# This is after the loop because it is no longer indented\nprint('Done!')\n```\n\nIf you iterate (loop) through a `dict`, you iterate through its keys. To iterate through the keys and the values at the same time, you can use `dict.items()` function, which returns an iterable of (key, value) tuples.\n\n\n```python\nages = {\n    'Jay-Z': 52,          # and counting\n    'Emanuel Macron': 44  # and counting\n}\nfor name, age in ages.items():\n    print(f'{name} is {age} years old')\n```\n\n<div class=\"exercise\" id=\"exercise_for\" markdown=\"1\">\n#### Mini exercise\n\nYou can also loop through a `str`, in which case you get individual characters as if you were looping through a `list` of characters. Use a `for` loop through loop through a `str` with the first five letters of the alphabet. Print out each character on a separate line. After the loop, print out 'Done!'\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">\na\nb\nc\nd\ne\nDone!\n</div>\n</div>\n\n## The while loop\n\nA `while` loop executes a code block until a particular condition is no longer `True`.\n\n\n~~~ .python\nuser_input = ''\nwhile user_input != 'quit':\n    user_input = input('>>> ')\n    print(f'The user said: {user_input}')\nprint('Quitting ...')\n~~~\n\n__Output:__\n\n~~~\n>>> Hello!\nThe user said: Hello!\n>>> quit\nThe user said: quit\nQuitting ...\n~~~\n\n\n<div class=\"exercise\" id=\"exercise_while\" markdown=\"1\">\n#### Mini exercise\n\nCreate a simple calculator for additions! Repeatedly ask the user to enter numbers. Each time that the user provides input, this input is first converted to `float` and then added to a running total (which should start from 0). When the user enters 'add', the `loop` stops and the running total is printed out.\n\nWhen running the code, enter '3', '2', '1', and 'add' to solve the exercise.\n\n<textarea class=\"code height200\"></textarea>\n<div hidden class=\"solution_output\">6.0</div>\n</div>\n\n## continue: abort one iteration\n\nThe `continue` statement, which you can use in `for` and `while` loops (but nowhere else), aborts a single iteration of a loop, and continues with the next iteration. To give an example, you can use `continue` to skip all cities that are not capitals:\n\n\n```python\ncities = ['Berlin', 'S\u00e3o Paulo', 'Tokyo', 'New York']\ncapitals = ['Berlin', 'Tokyo']\nfor city in cities:\n  # If the current city is not a capital, continue with the next city\n  if city not in capitals:\n    continue\n  print(f'{city} is a capital')\n```\n\n<div class=\"exercise\" id=\"exercise_continue\" markdown=\"1\">\n#### Mini exercise\n\nLoop through the `list` of four cities above. Use `continue` to ignore cities that have a space in the name. Print out the other city names. (Tip: You can use `in` to check whether one string is a substring of another string.)\n\n<textarea class=\"code height150\"></textarea>\n<div hidden class=\"solution_output\">\nBerlin\nTokyo\n</div>\n</div>\n\n## break: abort a loop\n\nThe `break` statement is similar to the `continue` statement, but aborts the loop entirely, rather than just aborting the current iteration. To give an example, you can use `break` to print out all prime numbers below `10`.\n\n\n```python\nfor prime in prime_numbers:\n  # Abort the loop when we reach a number that is 10 or higher\n  if prime >= 10:\n    break\n  print(prime)\n```\n\n<div class=\"exercise\" id=\"exercise_break\" markdown=\"1\">\n#### Mini exercise\n\nLoop through the `list` of four cities above. Print out the name of each city. Use `break` to stop after Tokyo.\n\n<textarea class=\"code height150\"></textarea>\n<div hidden class=\"solution_output\">\nBerlin\nS\u00e3o Paulo\nTokyo\n</div>\n</div>\n\n\n## Useful functions\n\n### range(): iterate through a range of values\n\n`range()` corresponds to a range of numbers. The simplest and most common use case is to specify only a stop value, which is exclusive (i.e. `range(3)` does not include `3`!):\n\n```python\nfor i in range(3):\n  print(i)\n```\n\nHowever, you can also specify a start value and a step size (negative step sizes allow you to count backwards):\n\n```python\nfrom_value = 1\nto_value = 4\nstep_size = 2\nfor i in range(from_value, to_value, step_size):\n  print(i)\n```\n\n<div class=\"exercise\" id=\"exercise_range\" markdown=\"1\">\n#### Mini exercise\n\nUse `range()` to count down from 5 to 1, printing each number on a separate line. After the loop, print 'Go!'.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">\n5\n4\n3\n2\n1\nGo!\n</div>\n</div>\n\n\n### zip(): iterate through multiple iterables\n\n`zip()` takes one or more iterables, and returns a zipped iterable in which elements from the original iterables are paired. This allows you to iterate through multiple iterables at the same time. The zipped iterable is as long as the shortest of the original iterables.\n\n\n```python\n# Source: https://en.wikipedia.org/wiki/List_of_best-selling_music_artists\nartists = 'The Beatles', 'Elvis Presley', 'Michael Jackson', 'Madonna'\nsales = 600e6, 600e6, 350e6, 300e6\nfor artist, sold in zip(artists, sales):\n  print(f'{artist} sold {sold} records'.format(artist, sold))\n```\n\n<div class=\"exercise\" id=\"exercise_zip\" markdown=\"1\">\n#### Mini exercise\n\nUse one `range()` to count down from 0 to 4, and another `range()` to count up from 4 to 0. Use `zip()` to loop through both ranges together. Print each pair of numbers out on a separate line in this format: '0 4', etc.\n\n<textarea class=\"code height150\"></textarea>\n<div hidden class=\"solution_output\">\n0 4\n1 3\n2 2\n3 1\n4 0\n</div>\n</div>\n\n\n### enumerate(): iterate and count\n\n`enumerate()` takes an iterable, and returns another iterable in which each element is paired with a counter variable.\n\n```python\ncities = ['Berlin', 'S\u00e3o Paulo', 'Tokyo', 'New York']\nfor i, city in enumerate(cities):\n  print(f'{i}: {city}')\n```\n\n<div class=\"exercise\" id=\"exercise_enumerate\" markdown=\"1\">\n#### Mini exercise\n\nUse `range()` to count down from 4 to 0. Use `enumerate()` to create another counter that goes for 0 to 4. Print each pair of numbers out on a separate line in this format: '0 4', etc. (I.e. the result is the same as for the previous mini exercise, but the implementation is different.)\n\n<textarea class=\"code height150\"></textarea>\n<div hidden class=\"solution_output\">\n0 4\n1 3\n2 2\n3 1\n4 0\n</div>\n</div>\n\n\n## Review exercises\n\n<div class='exercise no-progress' id='exercise_fibonacci' markdown=1>\n\n### Fibonacci\n\nCalculate the [Fibonacci series](https://en.wikipedia.org/wiki/Fibonacci_number) up to 1,000. Print out each Fibonacci number including its position in the series. Like so:\n\n~~~\n0: 1\n1: 1\n2: 2\n3: 3\n4: 5\netc.\n~~~\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:loops%-solution-1) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>\n\n<div class='exercise no-progress' id='exercise_artists' markdown=1>\n\n### Best-selling artists\n\nDo the following until the user enters `quit`:\n\n- Ask the name of an artist\n- Look up the number of sales of this artist in a `dict`\n- Print out the result if the number of sales are known\n- If the number of sales are unknown, ask the user to enter the number of sales, and update the `dict` accordingly\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:loops%-solution-2) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>",
    "title": "Loops: for and while",
    "url": "https://pythontutorials.eu/basic/loops",
    "path": "content/pages/basic/loops.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Files and folders\n\ntitle: Files and folders\n\n\n<div class=\"learning-goals\" markdown=\"1\">\nFiles and folders are the building blocks of computer data! Knowing how to programmatically navigate the file system and how to read from and write to files is a crucial skill. So let's learn how to do this!\n{.summary}\n\nIn this chapter, you will learn\n{.header}\n\n- Key terms and concepts related to files and folders\n- How to use the `Path` object\n- How to write to and read from files\n\nTest yourself\n{.header}\n\n- One interactive mini exercise\n- One review exercise\n</div>\n\n\n[TOC]\n\n\n## What are files, folders, and paths?\n\nComputer data is generally organized into *files* and *folders*. Files contain the actual data: images, text files, etc. Folders (or *directories*) are containers that contain files and other (sub)folders.\n\nFor example, my home folder (`/home/sebastiaan`) contains a subfolder called `coding`, which in turn contains two subfolders called `python` and `r`, which in turn contain a number of Python (`.py`) and R (`.R`) scripts with exercises. Like this:\n\n```\n/home/sebastiaan/coding/\n    python/\n        exercice1.py\n        exercise2.py\n    R/\n        exercise1.R\n        exercise2.R\n```\n\n\n### Important terms\n\nBefore we start, let's define the most important terms related to files and folders. You don't have to remember them right now, but you can refer back to this list when you encounter an unknown term later on.\n\n- A __path__ is the location of a file or folder.\n- The __root__ is the top-level folder of the path. On Mac OS and Linux, the root is simply `/`. On Windows, the root is the drive letter (e.g. `c:\\`). (We will return to differences between operating systems below.)\n- The __working directory__ is the currently active folder. When executing a Python script from a code editor, the working directory is usally the folder that contains the script.\n- The __home folder__ is the folder that contains user-specific files. My home folder is `/home/sebastiaan/`. The home folder is often abbreviated as `~/`.\n- An __absolute path__ specifies the location of a file or folder relative to the root. In the example above, the absolute path to `exercise1.py` is `/home/sebastiaan/coding/python/exercise1.py`.\n- A __relative path__ specifies the location of a file or folder relative to the working directory. In the example above, and assuming that I'm working in the folder `/home/sebastiaan/coding`, the relative path to `exercise1.py` is `coding/python/exercise1.py`. Note that a relative path doesn't start with a `/` (i.e. doesn't contain the root).\n- An __extension__ (or *suffix*) is the part of the path that follows (and includes) the final `.`. The extension of `exercise1.py` is `.py`. Extensions usually indicate the file type; for example, you can recognize Python scripts by the `.py` extension. Not all files have an extension.\n- A __wildcard__ is a special character that acts as a placeholder in a path. The most common wildcard is the `*`, which matches anything. For example, the wildcard string `*.py` matches any path that ends with `.py`.\n- A __glob__ is a collection of paths that matches a wildcard string. For example, the glob for `coding/python/*.py` consists of `exercise1.py` and `exercise2.py`.\n\n\n### Differences between operating systems\n\nMac OS and Linux use the (forward) slash (`/`) as a path separator; that is, the `/` separates individual folders and files in a path. In contrast, Windows uses the backslash (`\\`) as a path separator; absolute paths in windows also include a drive letter, such as `C:\\`.\n\nDifferent operating systems also use different naming conventions for home folders: Windows: `C:\\Users\\[name]`, Linux: `/home/[name]`, Mac OS: `/user/[name]`. (As you can tell from the name of my home folder, I use Linux.)\n\nLuckily, Python avoids you from having to worry about these differences: no matter with operating system you are using, you can use the `\\` path separator and `~` (or `Path.home()`) to refer to the home folder. Python will make sure that these paths are correctly interpreted on all operating systems.\n\n*Pro-tip:* As you've learned in the [Syntax](%url:syntax%) chapter, the backslash also serves as an escape character in Python; that is, the `\\` allows you to indicate non-printable characters, such as a tab stop (`\\t`) or line break (`\\n`). Therefore, it's easiest to avoid the backslash altogether when working with paths, even on Windows.\n\n\n## The pathlib module and the Path class\n\nThe `Path` class from the [`pathlib` module](https://docs.python.org/3/library/pathlib.html) provides an intuitive way work with files and folders. Let's create a `Path` object that corresponds to the `coding/python/` folder. We use a relative path and assume that my home folder is the current working directory.\n\n```python\nfrom pathlib import Path\npy_exercises = Path('coding/python/')\nprint(py_exercises)\n```\n\nPath objects can be combined using the `/` operator. Let's use this to create a new `Path` object that corresponds to `exercise1.py`:\n\n```python\npy_exercise1 = py_exercises / Path('exercise1.py')\nprint(py_exercise1)\n```\n\n`Path` objects have a number of convenient functions and properties:\n\n- `Path.exists()` returns `True` if the path corresponds to an existing file or folder\n- `Path.parent` returns the parent folder of a file or folder, such as `coding/python` for for `coding/python/exercise1.py`\n- `Path.is_file()` returns `True` if the path corresponds to an existing file\n- `Path.is_dir()` returns `True` if the path corresponds to an existing folder\n- `Path.name` returns the name without the parent folder, such as `exercise1.py` for `coding/python/exercise1.py`\n- `Path.stem` returns the name without the file extension, such as `exercise1` for `exercise1.py`\n- `Path.suffix` returns the file extension, such as `.py` for `exercise1.py`\n\n\n<div class=\"exercise\" id=\"exercise_if\" markdown=\"1\">\n#### Mini exercise\n\nCreate a path object that corresponds to the absolute path to `exercise1.py` and print it out. (Except for the most basic functionality, the `Path` class does not work in a browser. That's why this chapter only contains this one interactive mini exercise.)\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">/home/sebastiaan/coding/python/exercise1.py</div>\n</div>\n\n\n### Listing files and folders\n\nThe `Path.glob()` function returns a list of files and subfolders inside a folder. You can specify a wildcard string to indicate which files you want. To list all files, specify the `*` wildcard string (which matches any path).\n\n```python\nprint(f'All files in {py_exercises}:')\nfor path in py_exercises.glob('*'):\n    print(f'- {path}')\n```\n\n\n### Creating and removing files and folders\n\nSo far, we've worked with `Path` objects that correspond to files and folders that already exist. However, you can also create `Path` objects for files and folders that do not (yet) exist. The `Path.exists()` function allows you to tell whether or not a path exists.\n\nLet's say that we want to create a folder for exercises in the Julia programming language. We first create a Path object for this non-existing folder:\n\n```python\njl_exercises = Path('coding/julia')\nprint(jl_exercises.exists())\n```\n\nNext, we use the `Path.mkdir()` function to create an empty folder at this location:\n\n```python\njl_exercises.mkdir()\nprint(jl_exercises.exists())\n```\n\n*Pro-tip:* `Path.mkdir()` by default requires that the parent folder (`coding` in the example above) already exists. When this is not the case, you can use `Path.mkdir(parents=True)` to also create all non-existing parent folders.\n\nTo create an empty file inside this folder, we use the `Path.touch()`:\n\n```python\njl_exercise1 = jl_exercises / Path('exercise1.jl')\njl_exercise1.touch()\nprint(jl_exercise1.exists())\n```\n\nMost common operations related to files and folders can be handled by the `Path` class. Let's consider the most important functions:\n\n- `Path.mkdir()` creates a folder (see above)\n- `Path.rename()` renames a file or folder\n- `Path.rmdir()` deletes a folder (which cannot be empty, see below)\n- `Path.touch()` creates an empty file\n- `Path.unlink()` deletes a file\n\nHowever, there is one common scenario that the `Path` class *cannot* handle: deleting folders that are not empty. For example, if we would try to use `Path.rmdir()` to delete the `coding/julia` folder that we created above, then we would get an `OSError` because the directory isn't empty (it contains `exercise1.jl`):\n\n```python\n# should-raise\njl_exercises.rmdir()\n```\n\nTo recursively delete the folder, that is, to delete the folder and everything inside it, you can use `rmtree()` from the [`shutil` module](https://docs.python.org/3/library/shutil.html) instead.\n\n```python\nimport shutil\nshutil.rmtree(jl_exercises)\nprint(jl_exercises.exists())\n```\n\n*Pro-tip*: There is a lot of overlap between the functionality of the (newer) `Path` class and the (older) `os`, `os.path`, and `shutil` modules. For most purposes, using the `Path` class is recommended because it results in code that is easier to read and write.\n\n\n## Reading and writing files\n\n\n### Text files\n\n`py_exercise1` is a `Path` object that corresponds to the file `exercise1.py` (see above). To read the contents of this file, we can use `Path.read_text()`:\n\n```python\nprint(f'The contents of {py_exercise1} are:')\ncontents = py_exercise1.read_text()\nprint(contents)\n```\n\nWriting to text files is almost as easy as reading from them, using `Path.write_text()`:\n\n\n```python\ncontents = 'Define a factorial function using recursion!'\npy_exercise2 = Path('coding/python/exercise2.py')\npy_exercise2.write_text(contents)\n```\n\n*Pro-tip:* Calling `Path.write_text()` creates a new file and opens it for writing. This means that the file will be overwritten if it already existed. If you want to add text to an existing file without erasing its contents, you need to use a slightly more verbose approach, using a `with` context and `Path.open('a')` to indicate that you want to open the file in 'append' mode:\n\n```python\nwith py_exercise2.open('a') as fd:\n    fd.write('\\nThis line will be appended to the file')\n```\n\nFor the purpose of being able to append text to a file, it is not crucial to understand what a `with` context is exactly. However, if you want to fully understand the code above, take a look at [this page of the Python docs](https://docs.python.org/3/reference/compound_stmts.html#with).\n\n\n### Binary (non-text) files\n\nPython makes a distinction between text (`str` objects) and binary (`bytes` objects) data. Of course, text also consists of bytes, but there is an additional layer on top of it, namely the character encoding that specifies how bytes should be translated into human-readable text. Binary data does not have this and often does not correspond to human-readable text.\n\nImages are binary files. Say that we want to read a photo of De Boef, which you may meet later on in the deep-learning course chapter on [classifying images](%link:image-classification%). We can do this as follows:\n\n```python\nimg = Path('data/boef.jpg')\ncontents = img.read_bytes()\nprint(f'File contents are of type {type(contents)}')\n```\n\n![](data/boef.jpg)\n\nTo write binary data to a file, simply call `Path.write_bytes()`:\n\n```python\nimg_copy = Path('copy-of-boef.jpg')\nimg_copy.write_bytes(contents)\n```\n\n\n## Review exercise\n\n### An interactive file browser\n\nYou're going to build an interactive file browser! The program starts by listing all files and folders in the current working directory. The first entry in the list is a special entry that corresponds to the parent folder, called '..' (two dots is the standard way to indicate the parent folder); however, this entry is only available if the working directory isn't the root already! Each entry in the list is numbered, starting from 0. \n\nBy entering a number, the user can select a file or folder. Depending on what kind of file or folder it is, one of three things can happen:\n\n- If the user selects a folder or the '..' entry, the working directory is changed to that folder.\n- If the user selects a text file, the content of that file is printed out.\n- If the user selects a binary file, \u00b7the message '[file name] is not a text file' is printed out\n\nNext, the contents of the working directory (which may have changed) are shown again, and the user is prompted to provide new input, and so on, until the user enters `quit`. If the user enters something other than `quit` or a number that corresponds to an entry in the list, an informative warning message (such as 'Invalid user input') is printed out.\n\nAn interaction could look like this:\n\n~~~\nListing contents of /home/sebastiaan/coding\n0: ..\n1: python\n\n>>> 1\nListing contents of /home/sebastiaan/coding/python\n0: ..\n1: exercise1.py\n2: exercise2.py\n\n>>> quit\n~~~\n\nTips:\n\n- `Path.cwd()` returns the working directory\n- `os.chdir()` changes the working directory\n- Calling `Path.read_text()` on a binary file results in a `UnicodeDecodeError`\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:files-and-folders%-solution) to see one solution!\n\n\n<hr />\n\n\nThis concludes the Python Basics course. Congratulations\u2014you made it to the finish line!\n\n<div>\n<a class='btn btn-success btn-large btn-block' href='/'>Go back to the home page</a></p>\n</div>",
    "title": "Files and folders",
    "url": "https://pythontutorials.eu/basic/files-and-folders",
    "path": "content/pages/basic/files-and-folders.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Functions\n\ntitle: Functions\nnext_title: Modules\nnext_url: %url:modules%\n\n\n<div class=\"learning-goals\" markdown=\"1\">\nFunctions are blocks of code that you can call elsewhere in your code. Functions are one of the most important concepts in programming, so let's learn all about them!\n{.summary}\n\nIn this chapter, you will learn\n{.header}\n\n- What functions are\n- How to use the `def` statement to define a function\n- How to pass arguments and keywords to functions\n- About return values\n- About functions that call functions (recursion)\n\nTest yourself\n{.header}\n\n- Five interactive mini exercises\n- Two review exercises\n</div>\n\n\n[TOC]\n\n\n## Functions: what and why?\n\nA *function* is a re-usable code block, typically with a name. The main goal of functions is to avoid duplication of code. Another important goal of functions is to divide code into parts with clearly defined functions; doing so can drastically improve the readability of your code.\n\nSay that you want to turn a string with multiple words into an acronym, such that '<b>a</b> <b>c</b>oded <b>r</b>endition <b>o</b>f <b>n</b>ames <b>y</b>ielding <b>m</b>eaning' becomes 'ACRONYM'. You can do that by first splitting the string into separate words, iterating through the resulting list of words, turning the first letter of each word to uppercase, and concatening each first letter to a new string that, in the end, contains the acronym.\n\n```python\nwords = 'a coded rendition of names yielding meaning'\nacronym = ''\nfor word in words.split():\n  acronym += word[0].upper()\nprint(acronym)\n```\n\nSo far there is no code duplication, and hence no real need for a function. But now say that you want to do *almost* the same thing again for another string: 'New York City'. To do this without a function, we would have to copy-paste our code, resulting in code duplication:\n\n\n```python\nwords = 'a coded rendition of names yielding meaning'\nacronym = ''\nfor word in words.split():\n  acronym += word[0].upper()\nprint(acronym)\nwords = 'New York City'\nacronym = ''\nfor word in words.split():\n  acronym += word[0].upper()\nprint(acronym)\n```\n\nWhen you see this kind of code duplication, then you know that a function is likely to improve your code. Let's see, step by step, how we can accomplish this.\n\n\n## def: defining a function\n\nA function is defined with the `def` statement, followed by the name of the function and parentheses. Like any statement that is followed by an indented code block, the statement ends with a colon.\n\nLet's define an `acronym()` function that (for now) determines the acronym for 'a coded rendition of names yielding meaning' and prints out the result. We execute the function by calling its name followed by parentheses.\n\n\n```python\ndef acronym():  # Define the function\n  words = 'a coded rendition of names yielding meaning'\n  s = ''\n  for word in words.split():\n    s += word[0].upper()\n  print(s)\n\n\nacronym()  # Call the function\n```\n\n<div class=\"exercise\" id=\"exercise_def\" markdown=\"1\">\n#### Mini exercise\n\n(Following-up from the [`zip()` exercise](%url:loops%).) Define a function named `best_selling_artists` that prints out the [four best-selling artists of all time](https://en.wikipedia.org/wiki/List_of_best-selling_music_artists) and the number of records that they sold, with one line per artist in the following format: 'The Beatles sold 600000000.0 records'.\n\n<textarea class=\"code height250\"></textarea>\n<div hidden class=\"solution_validate\">\ntry:\n  correct = callable(best_selling_artists)\nexcept:\n  correct = False\n</div>\n</div>\n\n\n## Arguments and return values\n\n### Function arguments\n\nThe `acronym()` function defined above is not very useful, because it lacks flexibility. It determines an acronym but *only* for the string 'a coded rendition of names yielding meaning', which is hard-coded into the function. To make the function more flexible, you can add *arguments* (or *parameters*). That is, you pass one or more variables to the function, and the function then performs some operation on or with these variables.\n\n\n```python\ndef acronym(words):\n  s = ''\n  for word in words.split():\n    s += word[0].upper()\n  print(s)\n\n\nacronym('do it yourself')\n```\n\n<div class=\"exercise\" id=\"exercise_args\" markdown=\"1\">\n#### Mini exercise\n\nAs before, define a function named `best_selling_artists`. This time, let the function accept a single argument named `artist` and print the number of record sales for this artist in the following format: 'The Beatles sold 600000000.0 records'. If the artist is not known, use 0 for the number of record sales. (Tip: use a `dict` with artists as keys and record sales as values.)\n\n<textarea class=\"code height250\"></textarea>\n<div hidden class=\"solution_validate\">\ncorrect = True\ntry:\n  best_selling_artists(artist='boef')\n  best_selling_artists(artist='Madonna')\nexcept:\n  correct = False\n</div>\n</div>\n\n### Default function arguments (keywords)\n\nFunction arguments can have default values, so that you can, but do not have to, pass these arguments. Such arguments with default values are called *keywords*. We can redefine `acronym()` such that `words` is a keyword that has an empty string as a default value (for which the acronym is also an empty string).\n\n\n```python\ndef acronym(words=''):\n  s = ''\n  for word in words.split():\n    s += word[0].upper()\n  print(s)\n\n\nacronym()\n```\n\n<div class=\"exercise\" id=\"exercise_keywords\" markdown=\"1\">\n#### Mini exercise\n\nAs before, define a function named `best_selling_artists` that takes a single argument named `artist`. The function is identical to that of the previous mini exercise, except that `artist` should now have a default value of `None`. If no value for artist is specified when calling the function, the function should ask the user to enter an artist name using the `input()` function.\n\n<textarea class=\"code height250\"></textarea>\n<div hidden class=\"solution_validate\">\ndef input():\n  return 'dummy'\nold_input = __builtins__.input\n__builtins__.input = input\ntry:\n  best_selling_artists()\n  best_selling_artists(artist='Madonna')\n  correct = True\nexcept:\n  correct = False\n__builtins__.input = old_input\n</div>\n</div>\n\n\n### Return values\n\nMany functions also have *return values*; that is, they communicate a value back to where they were called from. We can redefine `acronym()` such that it doesn't print the acronym directly, but rather `return`s it.\n\n\n```python\ndef acronym(words=''):\n  s = ''\n  for word in words.split():\n    s += word[0].upper()\n  return s\n\n\nikea = acronym('Ingvar Kamprad Elmtaryd Agunnaryd')\nprint(ikea)\n```\n\n<div class=\"exercise\" id=\"exercise_return\" markdown=\"1\">\n#### Mini exercise\n\nAs before, define a function named `best_selling_artists` that takes a single argument named `artist` with a default value of `None`. The function is identical to that of the previous mini exercise, except that the number of record sales should now be returned, rather than printed out.\n\n<textarea class=\"code height250\"></textarea>\n<div hidden class=\"solution_validate\">\ndef input():\n  return 'dummy'\nold_input = __builtins__.input\n__builtins__.input = input\nimport operator\ncorrect = True\ntry:\n  if best_selling_artists() != 0:\n    correct = False\n  if not operator.gt(best_selling_artists(artist='Madonna'), 100000):\n    correct = False\nexcept:\n  correct = False\n__builtins__.input = old_input\n</div>\n</div>\n\n## Docstrings\n\nA documentation string, or *docstring*, is a `str` that directly follows the `def` line. This allows you to describe what the function does. In most cases, a docstring will be a multiline string. It is best practice to document all but the most trivial functions with a clear docstring!\n\n\n```python\ndef acronym(words=''):\n  \"\"\"Determines the acronym for a string.\"\"\"\n  s = ''\n  for word in words.split():\n    s += word[0].upper()\n  return s\n```\n\n<div class=\"exercise\" id=\"exercise_docstring\" markdown=\"1\">\n#### Mini exercise\n\nAs before, define a function named `best_selling_artists` that takes a single argument named `artist` with a default value of `None` and returns the number of record sales. Add a docstring to the function that concisely describes what the function does.\n\n<textarea class=\"code height250\"></textarea>\n<div hidden class=\"solution_validate\">\ntry:\n  correct = callable(best_selling_artists) and best_selling_artists.__doc__ is not None\nexcept:\n  correct = False\n</div>\n</div>\n\n\n## Functions that call functions\n\nMost programs consist of functions that call other functions that call yet other functions, etc. For example, we could define a function called `acronyms()` that takes a list of sentences, where each sentence is itself a string of multiple words, and return a list of corresponding acronyms.\n\n\n```python\ndef acronym(words=''):\n  \"\"\"Determines the acronym for a string.\"\"\"\n  s = ''\n  for word in words.split():\n    s += word[0].upper()\n  return s\n\n\ndef acronyms(sentences=[]):\n  \"\"\"Determines the acronyms for a list of strings\"\"\"\n  l = []\n  for words in sentences:\n    l.append(acronym(words))\n  return l\n  \n  \nl = acronyms(['a coded rendition of names yielding meaning',\n              'do it yourself',\n              'new york city',\n              'Ingvar Kamprad Elmtaryd Agunnaryd'])\nprint(l)\n```\n\n\n## Review exercises\n\n<div class='exercise no-progress' id='exercise_factorial_for' markdown=1>\n\n### Factorial using for\n\nThe [factorial](https://en.wikipedia.org/wiki/Factorial) (`!`) of a positive integer number is the product of all numbers from 1 up to and including the number itself. So `3! == 3 \u00d7 2 \u00d7 1`. By convention, `0! == 1`. The factorial of negative numbers is undefined.\n\nDefine a function that takes a number as an argument, and returns the factorial for that number. The function can assume that the input is a non-negative integer. Use a `for` loop inside the function.\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:functions%-solution-1) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>\n\n<div class='exercise no-progress' id='exercise_factorial_recursion' markdown=1>\n\n### Factorial using recursion\n\nWhen a function calls itself, this is called *recursion*. Define a factorial function that does *not* use a `for` loop, but uses recursion.\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:functions%-solution-2) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>",
    "title": "Functions",
    "url": "https://pythontutorials.eu/basic/functions",
    "path": "content/pages/basic/functions.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Functions: Exercises and Solutions\n\ntitle: Functions: Exercises and Solutions\nnext_title: Functions\nnext_url: %url:functions%\n\n\n## Factorial using recursion\n\n### Exercise\n\nWhen a function calls itself, this is called *recursion*. Define a factorial function that does *not* use a `for` loop, but uses recursion.\n\n\n\n### Solution\n\n```python\ndef factorial(i):\n\n  if not i: # 0 is False\n    return 1\n  return i * factorial(i - 1)\n\n\nprint('0! == {0}'.format(factorial(0)))\nprint('1! == {0}'.format(factorial(1)))\nprint('2! == {0}'.format(factorial(2)))\nprint('3! == {0}'.format(factorial(3)))\n```",
    "title": "Functions: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/functions-solution-2",
    "path": "content/pages/basic/functions-solution-2.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Basic Syntax: Exercises and Solutions\n\ntitle: Basic Syntax: Exercises and Solutions\nnext_title: Syntax\nnext_url: %url:syntax%\n\n\n## Pythagoras\n\n### Exercise\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Pythagorean.svg/390px-Pythagorean.svg.png)\n\nImagine a right triangle like the one above and:\n\n- Read a number from the standard input and assign it to `a`\n- Read another number from the standard input and assign it to `b`\n- Use Pythagoras theorem to determine the value of the long side `c`\n- Use string formatting to print out the length of the long side\n- If `c` is larger than `PI` (a constant), also print out: *And this is longer than PI*\n\n\n\n### Solution\n\n~~~ .python\nPI = 3.14\n\na = input('Length of a? ')\nb = input('Length of b? ')\na = float(a)\nb = float(b)\nc = (a ** 2 + b ** 2) ** .5\nprint('C has length {0}'.format(c))\nif c > PI:\n  print('And this is longer than PI')\n~~~\n\n__Output:__\n\n~~~\nLength of a? 1\nLength of b? 2\nC has length 2.23606797749979\n~~~",
    "title": "Basic Syntax: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/syntax-solution",
    "path": "content/pages/basic/syntax-solution.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Functions: Exercises and Solutions\n\ntitle: Functions: Exercises and Solutions\nnext_title: Functions\nnext_url: %url:functions%\n\n\n## Factorial using for\n\n### Exercise\n\nThe [factorial](https://en.wikipedia.org/wiki/Factorial) (`!`) of a positive integer number is the product of all numbers from 1 up to and including the number itself. So `3! == 3 \u00d7 2 \u00d7 1`. By convention, `0! == 1`. The factorial of negative numbers is undefined.\n\nDefine a function that takes a number as an argument, and returns the factorial for that number. The function can assume that the input is a non-negative integer. Use a `for` loop inside the function.\n\n\n\n### Solution\n\n```python\ndef factorial(i):\n\n  f = 1\n  for j in range(i):\n    f *= j + 1\n  return f\n\n\nprint('0! == {0}'.format(factorial(0)))\nprint('1! == {0}'.format(factorial(1)))\nprint('2! == {0}'.format(factorial(2)))\nprint('3! == {0}'.format(factorial(3)))\n```",
    "title": "Functions: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/functions-solution-1",
    "path": "content/pages/basic/functions-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Exceptions: error handling\n\ntitle: Exceptions: error handling\nnext_title: Files and folders\nnext_url: %url:files-and-folders%\n\n\n<div class=\"learning-goals\" markdown=\"1\">\nAn important programming skill is knowing how to deal with errors. In Python, errors are called `Exceptions`. Let's learn what these are!\n{.summary}\n\nYou will learn\n{.header}\n\n- What a `SyntaxError` is\n- What an `Exception` is\n- How to use the `try \u2026 except \u2026` statements to handle errors\n- How to use the `else \u2026 finally \u2026` statements for advanced error handling\n- How to use the `raise` keyword to indicate errors\n\nTest yourself\n{.header}\n\n- Three interactive mini exercises\n- One review exercise\n</div>\n\n\nThis tutorial contains three interactive mini exercises and one review exercise. Try to solve them all!\n\n\n[TOC]\n\n\n\n## `SyntaxError`s v `Exception`s\n\nA `SyntaxError` occurs when you try to run syntactically invalid Python code, that is, when you're asking Python to execute code that is not actually Python code. When this happens, the code is not executed at all, not even those lines that are syntactically valid. This is very different from an `Exception`!\n\n\n```python\n# should-raise\nif x = 0: # = should be ==\n  print('x is 0')\n```\n\nAn `Exception` occurs when there is an error during execution of syntactically valid Python code. In Python terminology, an `Exception` is *raised*. To illustrate this, let's define an unsafe function, that is, a function that can easily result in an `Exception`.\n\n\n```python\ndef oneover(i):\n  return 1 / i\n```\n\nCalling `oneover(0)` results in a `ZeroDivisionError` (a special kind of `Exception`) because dividing any number by `0` is not allowed:\n\n```python\n# should-raise\noneover(0)\n```\n\n<div class=\"exercise\" id=\"exercise_exception\" markdown=\"1\">\n#### Mini exercise\n\nA `ValueError` is a special kind of `Exception` that is raised when a function is called with an argument that has the correct type but an incorrect value. Trigger a `ValueError ` by trying to convert the string 'this is not an int' to an `int`.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_output\">invalid literal for int() with base 10: 'this is not an int'</div>\n</div>\n\n\n## Handling `Exception`s\n\n### try \u2026 except \u2026\n\nNow let's use a `try \u2026 except \u2026` statement to safely catch `Exception`s.\n\n```python\ntry:\n  i = oneover(0)\nexcept:  # A blank except is not good practice!\n  print('Some problem occurred')\nprint(\"I'm still alive!\")\n```\n\nIn the example above, if any `Exception` occurs in the block that follows the `try` statement, then the execution of that block is terminated, and the `except` block is executed. Importantly, however, the code continues to run; that is, `try \u2026 except \u2026` statements allow you to deal with `Exception`s gracefully.\n\nIt is good practice to specify *which* `Exception`s should be caught. For example, `oneover()` triggers a `ZeroDivisionError` error when called with `0` and a `TypeError` called it with a `str` or some other value that doesn't work in a numeric division. Therefore, we can specify that we want to catch only those two `Exception`s, and in addition specify that we want to keep the `Exception` object as the variable `e`. Restricting exception handling in this way avoids masking of errors that we did not anticipate, and which may reflects bugs in our code.\n\n\n```python\ntry:\n  i = oneover(0)\nexcept (TypeError, ZeroDivisionError) as e:\n  print('A problem occurred: %s' % e)\n```\n\nYou can also handle specify a different way to handle each different kind of `Exception` by having multiple `except` blocks:\n\n\n```python\ntry:\n  i = oneover(0)\nexcept TypeError:\n  # This will be executed when a TypeError is raised\n  print('oneover() expects a float or int')\nexcept ZeroDivisionError:\n  # This will be executed when a ZeroDivisionError is raised\n  print('oneover() cannot be called with 0')\n```\n\n\n### Re-raising (from)\n\nWe can also pass the `Exception` on after catching it, by doing a blank `raise`.\n\n\n```python\n# should-raise\ntry:\n  i = oneover(0)\nexcept ZeroDivisionError as e:\n  print('Oops!')\n  raise\n```\n\n\nOr you can do a `raise \u2026 from` (Python 3 only).\n\n\n```python\n# should-raise\ntry:\n    i = oneover(0)\nexcept ZeroDivisionError as e:\n    raise ValueError('Cannot divide by zero') from e\n```\n\n\n### else \u2026 finally \u2026\n\nThe `else` block of a `try \u2026 except \u2026` is executed when *no* `Exception` occurred during the `try` block. And finally there is a `finally` block, which is always executed, regardless of whether or not an `Exception` occurred; this can be used to perform clean-up operations etc.\n\n\n```python\ntry:\n    i = oneover('x')\nexcept ZeroDivisionError as e:\n    print('Cannot divide by zero')\nexcept TypeError as e:\n    print('Expecting a non-zero number')\nelse:\n    print('No exception occurred')\nfinally:\n    print('This is always executed')\n```\n\n<div class=\"exercise\" id=\"exercise_except\" markdown=\"1\">\n#### Mini exercise\n\nCreate a function called `safe_int()` that takes a single argument `i`. If possible, the function converts `i` to `int` and returns it. If not possible (i.e. if an `Exception` occurs), the function returns `None`.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_validate\">\ncorrect = 1\ntry:\n  if safe_int('10') != 10:\n    correct = 0\n  if safe_int('x') is not None:\n    correct = 0\nexcept:\n  correct = 0\n</div>\n</div>\n\n\n## Raising Exceptions\n\nYou can raise `Exception`s yourself to indicate that something went wrong. It is good practice to use Python's built-in `Exception` objects whenever this makes sense.\n\n```python\n# should-raise\ndef factorial(n):\n\n    if n < 0:\n        raise ValueError('Factorial expects non-negative integers')\n    return 1 if n == 0 else n*factorial(n-1)\n\n\nfactorial(-1)\n```\n\n\nBut you can also create custom `Exception` objects. This allows you to communicate clearly to the user what kind of error occurred.\n\n\n```python\n# should-raise\nclass FactorialError(Exception): pass\n\n\ndef factorial(n):\n\n    if n < 0:\n        raise FactorialError('Factorial expects non-negative integers')\n    return 1 if n == 0 else n*factorial(n-1)\n\n\nfactorial(-1)\n```\n\n\n<div class=\"exercise\" id=\"exercise_raise\" markdown=\"1\">\n#### Mini exercise\n\nDefine a function `capitalize_last_name()` that accepts as argument a string with a (single) first and a (single) last name, and returns a string in which only the first letter of the first name is uppercase, whereas all letters of the last name are uppercase; in otherwords, 'marisa tomei' becomes 'Marisa TOMEI'. (Tip: use `str.split()` to split a `str` into separate words.)\n\nIf something other than a `str` object is passed as an argument, the function should raise a `TypeError`. (Tip: you can use `isistance()` to check whether an object is of a particular type.) If the `str` does not consist of exactly two words, the function should raise a `ValueError`.\n\n<textarea class=\"code\"></textarea>\n<div hidden class=\"solution_validate height250\">\ncorrect = 1\ntry:\n  if capitalize_last_name('marisa tomei') != 'Marisa TOMEI':\n    correct = 0\n  try:\n    capitalize_last_name('marisa')\n  except ValueError:\n    pass\n  else:\n    correct = 0\n  try:\n    capitalize_last_name(0)\n  except TypeError:\n    pass\n  else:\n    correct = 0\nexcept:\n  correct = 0\n</div>\n</div>\n\n\n## Review exercise\n\n<div class='exercise no-progress' id='exercise_calculator' markdown=1>\n\n### An interactive calculator\n\nYou're going to write an interactive calculator! User input is assumed to be a formula that consist of a number, an operator (at least `+` and `-`), and another number, separated by white space (e.g. `1 + 1`). Split user input using [`str.split()`](https://docs.python.org/3/library/stdtypes.html#str.split), and check whether the resulting `list` is valid:\n\n- If the input does not consist of 3 elements, raise a `FormulaError`, which is a custom `Exception`.\n- Try to convert the first and third input to a `float` (like so: `float_value = float(str_value)`). Catch any `ValueError` that occurs, and instead raise a `FormulaError`\n- If the second input is not `'+'` or `'-'`, again raise a `FormulaError`\n\nIf the input is valid, perform the calculation and print out the result. The user is then prompted to provide new input, and so on, until the user enters `quit`.\n\nAn interaction could look like this:\n\n~~~\n>>> 1 + 1\n2.0\n>>> 3.2 - 1.5\n1.7000000000000002\n>>> quit\n~~~\n\n\nThis exercise is not checked automatically, because there are several possible solutions. Click [here](%url:exceptions%-solution) to see one solution!\n\n<textarea class=\"code height300\"></textarea>\n\n</div>",
    "title": "Exceptions: error handling",
    "url": "https://pythontutorials.eu/basic/exceptions",
    "path": "content/pages/basic/exceptions.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Iterables: Exercises and Solutions\n\ntitle: Iterables: Exercises and Solutions\nnext_title: Iterables\nnext_url: %url:iterables%\n\n\n## Best-selling artists\n\n### Exercise\n\nDefine an `artists` `dict` with the names of the [four best-selling music artists](https://en.wikipedia.org/wiki/List_of_best-selling_music_artists) as keys, and their claimed sales as values:\n\n1. The Beatles with 600 million sales\n2. Elvis Presley with 600 million sales\n3. Michael Jackson with 350 million sales\n4. Madonna with 300 million sales\n\nThen ask the user to enter the name of an artist. Look up the number of sales of this artist, falling back to 'unknown' if the artists is not in the `dict`, and print out the result.\n\n\n\n### Solution\n\n~~~ .python\nartists = {\n  'The Beatles': 600e6,\n  'Elvis Presley': 600e6,\n  'Michael Jackson': 350e6,\n  'Madonna': 300e6\n}\nartist = input('Enter an artist name: ')\nsold = artists.get(artist, 'unknown')\nprint('{0} has sold {1} records'.format(artist, sold))\n~~~\n\n__Output:__\n\n~~~\nEnter an artist name: Rick Ross\nRick Ross has sold unknown records\n~~~",
    "title": "Iterables: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/iterables-solution-2",
    "path": "content/pages/basic/iterables-solution-2.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Loops: Exercises and Solutions\n\ntitle: Loops: Exercises and Solutions\nnext_title: loops\nnext_url: %url:loops%\n\n\n## Best-selling artists\n\n### Exercise\n\nDo the following until the user enters `quit`:\n\n- Ask the name of an artist\n- Look up the number of sales of this artist in a `dict`\n- Print out the result if the number of sales are known\n- If the number of sales are unknown, ask the user to enter the number of sales, and update the `dict` accordingly\n\n\n\n### Solution\n\n~~~ .python\nsales = {}\nwhile True:\n  artist = input('Enter an artist name: ')\n  if artist == 'quit':\n    break\n  if artist in sales:\n    print('{0} has sold {1} records'.format(artist, sales[artist]))\n    continue\n  sold = input('Enter sales: ')\n  sales[artist] = sold\n~~~\n\n__Output:__\n\n~~~\nEnter an artist name: Michael Jackson\nEnter sales: 350000000\nEnter an artist name: Michael Jackson\nMichael Jackson has sold 350000000 records\nEnter an artist name: quit\n~~~",
    "title": "Loops: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/loops-solution-2",
    "path": "content/pages/basic/loops-solution-2.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Iterables: Exercises and Solutions\n\ntitle: Iterables: Exercises and Solutions\nnext_title: Iterables\nnext_url: %url:iterables%\n\n\n## Fibonacci\n\n### Exercise\n\nDefine a `fibonacci` `list` that corresponds to the [Fibonacci series](https://en.wikipedia.org/wiki/Fibonacci_number) up to 8. Then, use slicing to create two subseries:\n\n- `even_fibonacci`, with all numbers at even indices (0, 2, etc.); and\n- `odd_fibonacci`, with all numbers at odd indices (1, 3, etc.).\n\n\n\n### Solution\n\n```python\nfibonacci = [1, 1, 2, 3, 5, 8]\neven_fibonacci = fibonacci[::2]\nodd_fibonacci = fibonacci[1::2]\nprint('Fibonacci at even positions: {0}'.format(even_fibonacci))\nprint('Fibonacci at odd positions: {0}'.format(odd_fibonacci))\n```",
    "title": "Iterables: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/iterables-solution-1",
    "path": "content/pages/basic/iterables-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Modules: Exercises and Solutions\n\ntitle: Modules: Exercises and Solutions\nnext_title: Modules\nnext_url: %url:modules%\n\n\n## Some simple statistics\n\n### Exercise\n\nUse the `statistics` module to calculate the mean of all prime numbers below 10.\n\n\n\n### Solution\n\n```python\nimport statistics\n\nprime_numbers = [1, 3, 5, 7]\nm = statistics.mean(prime_numbers)\nprint('M = {0}'.format(m))\n```",
    "title": "Modules: Exercises and Solutions",
    "url": "https://pythontutorials.eu/basic/modules-solution-1",
    "path": "content/pages/basic/modules-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# NumPy: Exercises and Solutions\n\ntitle: NumPy: Exercises and Solutions\nnext_title: numpy\nnext_url: %url:numpy%\n\n\n## Removing extreme values\n\n### Exercise\n\n- Generate an array of a thousand random numbers\n- Print out the shape of the array, and the mean and standard deviation of these numbers\n- Remove all numbers that are more than one standard deviation above or below the mean\n- Again, print out the shape of the array, and the mean and standard deviation of the remaining numbers\n\n\n\n### Solution\n\n```python\nimport numpy as np\n\na = np.random.random(1000)\nm = np.mean(a)\nsd = np.std(a)\nprint('Before removing extreme values:')\nprint('N = {}, M = {}, SD = {}'.format(len(a), m, sd))\nnew_a = a[(a > m - sd) & (a < m + sd)]\nnew_m = np.mean(new_a)\nnew_sd = np.std(new_a)\nprint('After removing extreme values:')\nprint('N = {}, M = {}, SD = {}'.format(len(new_a), new_m, new_sd))\n```",
    "title": "NumPy: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/numpy-solution-1",
    "path": "content/pages/numerical/numpy-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Plotting with Seaborn and Maplotlib\n\ntitle: Plotting with Seaborn and Maplotlib\nnext_title: Statistics\nnext_url: %url:statistics%\n\n\n[TOC]\n\n\n## Libraries for plotting\n\nThe traditional Python library for plotting (or data visualization) is [Matplotlib](https://matplotlib.org/). This is a comprehensive library that allows you to create any kind of plot that you can think of. However, Matplotlib can be cumbersome to use. Therefore, [Seaborn](https://seaborn.pydata.org/) was built on top of Matplotlib to make it easier to create common plot types, such as bar plots, or line plots (which Seaborn calls 'point plots').\n\n\n## Plotting simple lines and dots\n\nIt is convention to import `matplotlib.pyplot` as `plt`. This is the module that contains most of the plotting functions. The main plotting function is [`plt.plot()`](https://matplotlib.org/3.2.2/api/_as_gen/matplotlib.pyplot.plot.html). You can call `plt.plot()` multiple times, and then call `plt.show()` to show the resulting plot. If you do this from a code editor that supports this, such as Rapunzel or Spyder, the plot will be shown in the interactive console. Otherwise the plot will pop up in a separate window.\n\n\n\n```python\nfrom matplotlib import pyplot as plt\n\n# Simplest case: only specify Y values\nplt.plot([10, 11])\n# Specfy both X and Y values\nplt.plot([0, 1], [11, 10])\n# Also specify a line format (circles with dotted lines) and a color\nplt.plot([0, 1], [10.5, 10.5], 'o:', color='blue')\nplt.show()\n```\n\nThere are many functions to make your plot look better, for example by adding labels to the axes. You can find a list of all functions [here](https://matplotlib.org/3.2.2/api/_as_gen/matplotlib.pyplot.html).\n\nLet's consider a slightly more realistic example: a scatterplot of movie ratings over the years, based on [this data](/data/movies.xlsx).\n\n\n```python\nfrom datamatrix import io\n\ndm = io.readxlsx('data/movies.xlsx')\n# The ',' format indicates tiny markers without lines\nplt.plot(dm.year, dm.rating, ',')\nplt.xlabel('Year')\nplt.ylabel('Rating')\nplt.title('Movie ratings over the years')\nplt.show()\n```\n\n\n## Creating common plots\n\n\n### Point plot (also: line plot)\n\nIt is convention to import `seaborn` as `sns`. Seaborn is not as powerful as Matplotlib, but it has several convenient functions for creating common plot types. Often you will still use Matplotlib in addition to Seaborn to perfect your plot, for example by adding labels.\n\nMost Seaborn functions, including `sns.pointplot()`, take a DataMatrix or DataFrame object with the `data` keyword. You also need to specify which columns should be used for the X and the Y axes. You can optionally specify a `hue` keyword (not used here), which specifies a column that should be used to draw differently colored lines (in the case of a point plot), differently colored bars (in the case of a bar plot), etc.\n\n\n```python\nimport seaborn as sns\n\ndm90s = (dm.year > 1990) & (dm.year < 2000)\nsns.pointplot(x='year', y='rating', data=dm90s)\nplt.xlabel('Year')\nplt.ylabel('Rating')\nplt.show()\n```\n\n\n### Bar plot\n\nLet's again consider [this dataset](/data/heartrate.csv) from Moore, McCabe, & Craig (included as example data with JASP). This data contains the heart rate of male and female runners and control participants. So let's plot heart rate as a function of Gender (X axis) and Group (hue).\n\n\n```python\ndm = io.readtxt('data/heartrate.csv')\nsns.barplot(\n    x='Gender',\n    y='Heart Rate',\n    hue='Group',\n    data=dm\n)\nplt.xlabel('Gender')\nplt.ylabel('Heart rate')\nplt.show()\n```\n\n\n### Distribution plot (also: histogram)\n\nThe plots above show average values. It's also important to have a sense of how data is distributed. Creating a distribution plot is very easy with Seaborn. (Incidentally, this example also show how you can refer to column names that contains spaces, special characters, etc.: with `dm['column_name']` instead of the normal `dm.column_name` syntax.)\n\n```python\nsns.distplot(dm['Heart Rate'])\nplt.show()\n```\n\n\n## Creating subplots\n\nYou can create subplots with `plt.subplot()`. This takes a number of rows, a number of columns, and then the number of the subplot, where subplots are numbered from left to right and then from top to bottom. So if you have 3 (rows) x 3 (columns) plot, then subplot 4 would be the first subplot on the middle row.\n\nYou can use `plt.subplots_adjust()` to add some spacing between the rows (`hspace`) and the columns (`wspace`).\n\n```python\nfrom datamatrix import operations as ops\n\ndm_female, dm_male = ops.split(dm.Gender, 'Female', 'Male')\nplt.subplots_adjust(wspace=.4)\nplt.subplot(1, 2, 1)\nplt.title('Women')\nsns.barplot(x='Group', y='Heart Rate', data=dm_female)\nplt.ylim(90, 160)\nplt.xlabel('Group')\nplt.ylabel('Heart rate')\nplt.subplot(1, 2, 2)\nplt.title('Men')\nsns.barplot(x='Group', y='Heart Rate', data=dm_male)\nplt.ylim(90, 160)\nplt.xlabel('Group')\nplt.ylabel('Heart rate')\nplt.show()\n```\n\n## Exercises\n\n<div class='info-box' markdown=1>\n\n### Plotting rank-ordered ratings for 90s movies\n\nUsing [this dataset](/data/movies.xlsx), for each year in the 90s separately, plot the ratings for individual movies, rank-ordered such that the lowest-rated movies start on the left. The resulting plot consists of ten lines (for each year in the 90s) that gradually go up, with each datapoint corresponding to a single movie rating.\n\n\n[View solution](%url:plotting%-solution-1)\n\n</div>\n\n<div class='info-box' markdown=1>\n\n### Plotting heart-rate distributions in subplots\n\nUse [this dataset](/data/heartrate.csv) from Moore, McCabe, & Craig to create a two-by-two plot, and in each subplot show the distribution of heart rate for one combination of gender and group of participants (Men Runners, Men Control, Female Runners, Female Control).\n\n\n[View solution](%url:plotting%-solution-2)\n\n</div>",
    "title": "Plotting with Seaborn and Maplotlib",
    "url": "https://pythontutorials.eu/numerical/plotting",
    "path": "content/pages/numerical/plotting.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Plotting: Exercises and Solutions\n\ntitle: Plotting: Exercises and Solutions\nnext_title: Plotting\nnext_url: %url:plotting%\n\n\n## Plotting rank-ordered ratings for 90s movies\n\n### Exercise\n\nUsing [this dataset](/data/movies.xlsx), for each year in the 90s separately, plot the ratings for individual movies, rank-ordered such that the lowest-rated movies start on the left. The resulting plot consists of ten lines (for each year in the 90s) that gradually go up, with each datapoint corresponding to a single movie rating.\n\n\n\n### Solution\n\n\n```python\nfrom matplotlib import pyplot as plt\nfrom datamatrix import io, operations as ops\n\ndm = io.readxlsx('data/movies.xlsx')\ndm = (dm.year >= 1990) & (dm.year < 2000)\nfor year, year_dm in ops.split(dm.year):\n    plt.plot(sorted(year_dm.rating), label=year)\nplt.legend(title='Year')\nplt.ylabel('Rating')\nplt.xlabel('Movie #')\nplt.show()\n```",
    "title": "Plotting: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/plotting-solution-1",
    "path": "content/pages/numerical/plotting-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Working with tabular data using DataMatrix\n\ntitle: Working with tabular data using DataMatrix\nnext_title: Plotting\nnext_url: %url:plotting%\n\n\n[TOC]\n\n\n## What is DataMatrix?\n\n[DataMatrix](https://pydatamatrix.eu/) is a Python library for working with tabular data, i.e. spreadsheet-like data that consists of named columns and numbered rows. DataMatrix is a light-weight library that allows you to do many things in an intuitive way. (For more advanced functionality, you can use [pandas](https://pandas.pydata.org/).).\n\nThis tutorial is an abbreviated version of the following page:\n\n- <https://pydatamatrix.eu/basic/>\n\n\n## Basics\n\n\n### Creating a DataMatrix\n\nCreate a new `DataMatrix` object. The `length` keyword specifies the number of rows. A newly created `DataMatrix` doesn't have any columns yet.\n\n```python\nfrom datamatrix import DataMatrix\n\ndm = DataMatrix(length=3)\nprint(dm)\n```\n\n\n### Working with columns\n\nIf you assign a value to a column that doesn't exist, the column will be automatically created. If you assign a single value to a column, this will set all cells to that value:\n\n```python\ndm.col = 'This creates a new column'\nprint(dm)\n```\n\nIf you assign a sequence to a column, this will set the cells based on that sequence. This sequence must have the same length as the column (3 in this case).\n\n```python\ndm.col = 'one', 'two', 'three'\nprint(dm)\n```\n\n\n### Slicing and assigning to column cells\n\nYou can assign to one cell, to multiple cells at the same time, or to a slice of cells.\n\n```python\ndm.col[1] = ':-)'  # Assign to one cell\ndm.col[0, 2] = ':P'  # Assign to two cells\ndm.col[2:] = ':D'  # Assing to a slice of cells\nprint(dm)\n```\n\n\n### Column properties\n\nBasic numeric properties, such as the mean, can be accessed directly. Only numeric values are taken into account.\n\n```python\ndm.col = 1, 2, 'not a number'\n# Numeric descriptives\nprint('mean: %s' % dm.col.mean)\nprint('median: %s' % dm.col.median)\nprint('standard deviation: %s' % dm.col.std)\nprint('sum: %s' % dm.col.sum)\nprint('min: %s' % dm.col.min)\nprint('max: %s' % dm.col.max)\n# Other properties\nprint('unique values: %s' % dm.col.unique)\nprint('number of unique values: %s' % dm.col.count)\nprint('column name: %s' % dm.col.name)\n```\n\n\n### Iterating over rows, columns, and cells\n\nBy iterating directly over a `DataMatrix` object, you get successive `Row` objects. From a `Row` object, you can directly access cells. By iterating over a `Row` object, you get `column name, cell value` tuples.\n\n```python\ndm.col = 'a', 'b', 'c'\nfor row in dm:\n    print(row.col)\n    for colname, cell in row:\n        print('{} = {}'.format(colname, cell))\n```\n\nBy iterating over `DataMatrix.columns`, you get successive `(column_name, column)` tuples.\n\n```python\nfor colname, col in dm.columns:\n    print('{} = []'.format(colname, col))\n```\n\nBy iterating over a column, you get successive cells:\n\n```python\nfor cell in dm.col:\n    print(cell)\n```\n\nThe `column_names` property gives a sorted list of all column names (without the corresponding column objects):\n\n```python\nprint(dm.column_names)\n```\n\n\n### Element-wise column operations\n\nYou can apply basic mathematical operations on all cells in a column simultaneously. Cells with non-numeric values are ignored, except by the `+` operator, which then results in concatenation.\n\n```python\ndm = DataMatrix(length=3)\ndm.col = 0, 'a', 20\ndm.col2 = dm.col * .5\ndm.col3 = dm.col + 10\ndm.col4 = dm.col - 10\ndm.col5 = dm.col / 50\nprint(dm)\n```\n\nYou can apply a function (or `lambda` expression) to all cells in a column simultaneously with the `@` operator.\n\n```python\ndef times_two_plus_one(x):\n    return x * 2 + 1\n\ndm = DataMatrix(length=3)\ndm.col = 0, 1, 2\ndm.col2 = dm.col @ times_two_plus_one\nprint(dm)\n```\n\n\n### Reading and writing files\n\nYou can read and write files with functions from the `datamatrix.io` module. The main supported file types are `csv` and `xlsx`.\n\n```python\nfrom datamatrix import io\n\ndm = DataMatrix(length=3)\ndm.col = 1, 2, 3\n# Write to disk\nio.writetxt(dm, 'my_datamatrix.csv')\nio.writexlsx(dm, 'my_datamatrix.xlsx')\n# And read it back from disk!\ndm = io.readtxt('my_datamatrix.csv')\ndm = io.readxlsx('my_datamatrix.xlsx')\n```\n\n\n## Splitting and selecting data\n\n### Selecting\n\nYou can select by directly comparing columns to values. This returns a new `DataMatrix` object with only the selected rows.\n\n```python\ndm = DataMatrix(length=10)\ndm.col = range(10)\ndm_subset = dm.col > 5\nprint(dm_subset)\n```\n\nYou can select by multiple criteria using the `|` (or), `&` (and), and `^` (xor) operators (but not the actual words 'and' and 'or'). Note the parentheses, which are necessary because `|`, `&`, and `^` have priority over other operators.\n\n```python\ndm_subset = (dm.col < 1) | (dm.col > 8)\nprint(dm_subset)\n```\n\n\n### Splitting\n\nYou can also split a DataMatrix into subsets, using the `split()` function from `datamatrix.operations` (usually imported as `ops`). To do this, specify a column with discrete values that indicate the groups into which you want to split. For example, consider [this dataset](/data/heartrate.csv) from Moore, McCabe, & Craig (included as example data with JASP). This contains heart rate values for runners and non-runners (controls).\n\nThe first way to use `ops.split()` is by only specifying a column to split the data based on. In this case, the function returns a sequence of `value, subdatamatrix` tuples that you can iterate through with a `for` loop: (Note the alternative way to refer to columns that contain spaces or non-ascii characters: `dm['Heart Rate']`.)\n\n\n```python\nfrom datamatrix import io\nfrom datamatrix import operations as ops\n\ndm = io.readtxt('data/heartrate.csv')\nfor group, group_dm in ops.split(dm.Group):\n    print('Mean heart rate for {} is {} bpm'.format(\n        group,\n        group_dm['Heart Rate'].mean)\n    )\n```\n\nThe second way to use `ops.split()` is by also specifying the values that you want to split on. In this case, the function returns a sequence of `subdatamatrix` objects that match the order of the splitting values. Like so:\n\n\n```python\ndm_runner, dm_control = ops.split(dm.Group, 'Runners', 'Control')\nprint('Mean heart rate for runners is {} bpm'.format(dm_runner['Heart Rate'].mean))\nprint('Mean heart rate for controls is {} bpm'.format(dm_control['Heart Rate'].mean))\n```\n\n## Exercises\n\n<div class='info-box' markdown=1>\n\n### Analyzing movie ratings\n\nDownload [this file](/data/movies.xlsx) and read it with DataMatrix. The file contains titles, years, and ratings for many movies. Select only movies that were released between 1990 and 2000. Then, for each year separately, print the mean rating for the movies released in that year.\n\n\n[View solution](%url:datamatrix%-solution-1)\n\n</div>\n\n<div class='info-box' markdown=1>\n\n### Removing poorly performing participants\n\nThis is a challenging exercise!\n\nDownload [this dataset](/data/zhou_et_al_2020_exp1.csv) from Zhou et al. (2020) and read it with datamatrix. This dataset contains reaction times on a search task (`search_rt`) for different participants (`subject_nr`). Each row in this dataset corresponds to a single response, i.e. it is unaggregated data. \n\nThe goal of this exercise is to remove all data from those participants whose mean reaction time deviates more than two standard deviations from the grand mean reaction time. Here, both the standard deviation and the grand mean are derived from per-participant mean reaction times (i.e. a mean-of-means approach). \n\nHints:\n\n- You first need to create a datamatrix with the mean reaction time for each participant.\n- The function `datamatrix.operations.group()` groups a datamatrix based on a column, in this case `subject_nr`. The resulting datamatrix will contain a `search_rt` column for each subject, where each cell contains multiple values (i.e. multiple reaction times).\n- You can use `datamatrix.series.reduce_()` to get the mean reaction time for each subject.\n\n\n[View solution](%url:datamatrix%-solution-2)\n\n</div>",
    "title": "Working with tabular data using DataMatrix",
    "url": "https://pythontutorials.eu/numerical/datamatrix",
    "path": "content/pages/numerical/datamatrix.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Working with NumPy arrays\n\ntitle: Working with NumPy arrays\nnext_title: DataMatrix\nnext_url: %url:datamatrix%\n\n\n[TOC]\n\n\n## What is NumPy?\n\n[NumPy](https://numpy.org/) is a Python library built around the concept of arrays, which are collections of elements. The elements of a NumPy array are usually (but not necessarily) numbers, and NumPy allows you to perform calculations with those numbers.\n\nEverything that you can do with NumPy, you can also do with built-in Python objects (notably `list`s, see [iterables](%url:iterables%)). But NumPy is *much* faster and, in many cases, more elegant.\n\nNumPy is not part of the Python standard library. However, it is such a widely used library that it is pre-installed in most Python environments.\n\n\n## Arrays\n\n\n### Dimensions\n\nNumPy arrays are called `ndarray` objects. The `nd` stands for \"N-dimensional\", which is indicates that an array can have any numbers of dimensions. A 1D array is like a `list`, because you need only a single coordinate (or index) to indicate an element. A 2D array is like a spreadsheet, because you need two coordinates (a row and a column, or an X and a Y coordinate) to indicate an element. Higher-dimensional arrays are also possible, although arrays of more than three dimensions are difficult to mentally picture. (But this is a limitation of your brain, not of NumPy!)\n\nA real-life example of a 5D array might be an fMRI dataset (a brain scan) of multiple participants. Here, the first three dimensions would be space (X, Y, Z), because a brain is a 3D object. The fourth dimension would time, because an fMRI scan measures brain activity over time. And the fifth dimension would be the participant, because there are multiple participants. Therefore, you need five numbers to identify an element in this dataset (X, Y, Z, time, participant number).\n\n\n### Data types\n\nA NumPy array has a single data type (its `dtype`), and all elements in the array are of that type. This is different from a `list` object, which can contain elements of different types. The most common data types for NumPy arrays are `bool`, `int`, `float`, and `str`.\n\n\n## Creating an array\n\nFirst, we're going to import `numpy` with the alias `np` (see [modules](%url:modules%)). The `np` alias is by convention, and has the advantage that it requires less typing than `numpy`.\n\n```python\nimport numpy as np\n```\n\nYou can create an array directly from a `list`. If you pass a `list` of `list`s, as in the example below, the array will become 2D; you can tell this from the shape property, which returns the size of each dimension. The length of an array is the size of the first dimension. The `dtype` of the array will also be automatically determined, unless you explicitly specify this with the `dtype` keyword. In this case, it's an `int` array (or `int64`, ).\n\n```python\na = np.array([[1, 2, 3], [4, 5, 6]])\nprint(a)\nprint('dtype: {}'.format(a.dtype))\nprint('shape: {}'.format(a.shape))\nprint('length: {}'.format(len(a)))\n```\n\nIf you want an array of only zeros, you can use `np.zeros()`. If you want an array of only ones, you can use `np.ones()`. The only required argument is the desired shape.\n\n```python\nprint('zeros:')\nprint(np.zeros((2, 3)))\nprint('ones:')\nprint(np.ones((2, 3)))\n```\n\nThe NumPy equivalent of `range()` is `np.arange()`. `np.linspace()` is similar to `np.arange()` but differs in its arguments.\n\n```python\nprint(np.arange(start=0, stop=2, step=0.5))\nprint(np.linspace(start=0, stop=1.5, num=4))\n```\n\nAnd finally, the `np.random` module has functions for generating random numbers. For example, `np.random.random()` generates random `float`s between 0 and 1:\n\n```python\nprint(np.random.random((2, 3)))\n```\n\n\n## Indexing and slicing\n\nLet's start with a 2D array of numbers. First create a 1D array with `np.arange()` and then simply change its shape (this is allowed as long as the shape is compatible with the number of elements in the array).\n\n```python\na = np.arange(9)\na.shape = 3, 3\nprint(a)\n```\n\nTo get a single number, specify the row (1) and column (2), as always starting from 0:\n\n```python\nprint(a[1, 2])\n```\n\nTo get a single row, specify the index of that row:\n\n```python\nprint(a[1])\n```\n\nTo get multiple rows, specify a slice:\n\n```python\nprint(a[1:3])\n```\n\nTo get a column, get the full slice of rows (`:`), and then specify the column index: (The column now looks like a row, because the result is 1D!)\n\n\n```python\nprint(a[:, 1])\n```\n\nOr to get multiple columns:\n\n```python\nprint(a[:, 1:3])\n```\n\n## Selecting elements\n\nConsider the expression (`a > 2`):\n\n```python\nprint(a)\nprint('Larger than 2?')\nprint(a > 2)\n```\n\nFor each element of the array, NumPy checks whether the value is larger than 2. The result is an array of `bool` values. This `bool` array is in itself not that useful, but you can use it to index the original array, like so:\n\n```python\nprint(a[a > 2])\n```\n\nYou now get an array of elements that are larger than 2. This array is only 1D, even though the original array was 2D. This is because you have 'shot holes' in the array, and NumPy deals with this by flattening the resulting selection to a 1D array.\n\nYou can also select based on multiple criteria. The normal Python operators `and` and `or` don't work in this context! Instead, you have to use `&` (and) and `|` (or). And you have to put parentheses around the criteria. Like so:\n\n```python\nprint(a[(a > 2) & (a < 7)])\n```\n\n\n## Mathematical operations\n\nIf you apply the standard mathematical operators (`*`, `/`, `+`, `-`, `%`, `**`, `//`) to an array, then this operator is applied to each element separately, resulting in a new array. You can even apply multiple operators in a single expression:\n\n```python\nprint(a)\nprint('a * 2 - 2:')\nprint(a * 2 - 2)\n```\n\nNumPy has many built-in functions for applying mathematical operations to arrays, such as `np.sqrt()`, `np.exp()`, `np.log()`, etc.\n\n```python\nprint(a)\nprint('sqrt(a):')\nprint(np.sqrt(a))\n```\n\n\n## Mean, median, and standard deviation\n\nYou can easily get the mean, median, and standard deviation of an array:\n\n```python\nprint(a)\nprint('mean = {}\\nmedian = {}\\nstd = {}'.format(\n    np.mean(a),\n    np.median(a),\n    np.std(a)\n))\n```\n\nIf you have a multidimensional array, then you can specify the axis across which the mean should be calculated. You can even specify multiple axes; this sounds a bit abstract, but you can think of it as specifying which dimensions should be averaged out. Therefore, specifying all axes is the same as taking the mean across the entire array.\n\n```python\na = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\nprint(a)\nprint('mean(across first axis) = {}'.format(a.mean(axis=0)))\nprint('mean(across second axis) = {}'.format(a.mean(axis=1)))\nprint('mean(across all axes) = {}'.format(a.mean(axis=(0, 1))))\n```\n\nIf an array contains `nan` values (see [syntax](%url:syntax%)), then each of the above functions will also return `nan`. This is because of the mathematical convention that every operation that involves a `nan` evaluates to `nan`. However, this behavior is often not what you want, and therefore NumPy contains functions that explicitly ignore `nan` values:\n\n```\na = np.linspace(0, 10, 5)\na[0] = np.nan\nprint(a)\nprint('mean = {}\\nmedian = {}\\nstd = {}'.format(\n    np.mean(a),\n    np.median(a),\n    np.std(a)\n))\nprint('nanmean = {}\\nnanmedian = {}\\nnanstd = {}'.format(\n    np.nanmean(a),\n    np.nanmedian(a),\n    np.nanstd(a)\n))\n```\n\n\n## Exercises\n\n<div class='info-box' markdown=1>\n\n### Removing extreme values\n\n- Generate an array of a thousand random numbers\n- Print out the shape of the array, and the mean and standard deviation of these numbers\n- Remove all numbers that are more than one standard deviation above or below the mean\n- Again, print out the shape of the array, and the mean and standard deviation of the remaining numbers\n\n\n[View solution](%url:numpy%-solution-1)\n\n</div>\n\n<div class='info-box' markdown=1>\n\n### Activity in the left vs right brain\n\n- Read [this dataset](/data/fmri-data.npy), which has been adapted from the [StudyForrest](http://studyforrest.org/) project. It is an `.npy` file, which you can read with `np.load()`.\n- This will give you a 4D array with the following dimensions: left-to-right, back-to-front, bottom-to-top, time (1 sample per 2 s). Values in the array correspond to BOLD values (an indirect measure of brain activity).\n- First, inspect the shape of the array to see how big each dimension is.\n- Next, print out the average BOLD value separately for the left and the right side of the brain!\n\n\n[View solution](%url:numpy%-solution-2)\n\n</div>",
    "title": "Working with NumPy arrays",
    "url": "https://pythontutorials.eu/numerical/numpy",
    "path": "content/pages/numerical/numpy.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Time series: Exercises and Solutions\n\ntitle: Time series: Exercises and Solutions\nnext_title: Time series\nnext_url: %url:time-series%\n\n## The impact of crises\n\n\n### Exercise\n\nTake the datamatrix (`sm`) that you have constructed during this chapter. During the period that this dataset spans, two major crises occurred: the 2008 financial crisis and the 2020 corona crisis.\n\nFirst, quantify the impact of both crises on the per-capita GDP of each country. For the 2008 financial crisis, the impact can be quantified as the difference between per-capita GDP in 2009 and 2007. For the corona crisis, the impact can be quantified as the difference between 2020 and 2019.\n\nNext, create a scatter plot with the 2008-crisis impact on the x-axis, the corona-crisis impact on the y-axis, and individual countries as points. Draw dotted black lines (one horizontal and one vertical) through the 0 points for both axes. Draw solid red lines (one horizontal and one vertical) to indicate the mean impact of each crisis across countries.\n\n\n\n### Solution\n\nFirst, load the data and process it. These are the same steps as described in more detail in the chapter.\n\n```python\nfrom datamatrix import io, NAN, series as srs, operations as ops\n\ndm = io.readtxt('data/eurostat-gdp.csv')\ndm.gdp[dm.gdp != int] = NAN\nsm = ops.group(dm, by=dm.country)\nshift = sm.year[:, 0] - 2000\nsm.year = srs.roll(sm.year, shift)\nsm.gdp = srs.roll(sm.gdp, shift)\n```\n\nNext, solve the exercise!\n\n```python\nfrom matplotlib import pyplot as plt\n\nsm.gdp_2009_2007 = sm.gdp[:, 9] - sm.gdp[:, 7]\nsm.gdp_2020_2019 = sm.gdp[:, 20] - sm.gdp[:, 19]\nplt.figure(figsize=(11, 11))\nplt.axhline(0, color='black', linestyle=':')\nplt.axvline(0, color='black', linestyle=':')\nplt.plot(sm.gdp_2009_2007, sm.gdp_2020_2019, 'o')\nplt.xlabel('Per-capita GDP 2009 - 2007 (\u20ac)')\nplt.ylabel('Per-capita GDP 2020 - 2019 (\u20ac)')\nplt.axvline(sm.gdp_2009_2007.mean, color='red')\nplt.axhline(sm.gdp_2020_2019.mean, color='red')\nplt.show()\n```",
    "title": "Time series: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/time-series-solution-1",
    "path": "content/pages/numerical/time-series-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Introduction to data science with Python\n\ntitle: Introduction to data science with Python\nnext_title: NumPy\nnext_url: %url:numpy%\n\n\n[TOC]\n\n\n## About this course\n\nIn this course, you will learn the basic principles of data science with Python. That is, you will learn how to work with the most important Python libraries for numerical computing, to work with different kinds of data (arrays, column-based data, and time series), to create plots, and to perform statistical analyses.\n\n\n%--\nfigure:\n id: FigSnake\n source: friendly-snake.png\n caption: Your friendly Python teacher\n--%\n\n\n## Installing required packages\n\nBefore you get started, you need to install several libraries that you will use (either directly or indirectly) during the course. You can do this with `pip`:\n\n```text\npip install numpy scipy matplotlib seaborn statsmodels pandas pingouin datamatrix prettytable fastnumbers openpyxl\n```\n\nOr with `conda`:\n\n```text\nconda install numpy scipy matplotlib seaborn statsmodels pandas pingouin datamatrix prettytable fastnumbers openpyxl\n```\n\n\n## Course overview\n\nOnce you're all set, let's dive into the chapters! Each chapter builds on the previous chapters, so it is recommended to follow the chapters in order!\n\n1. Introduction to data science with Python (this chapter)\n2. [Working with NumPy arrays](%url:numpy%)\n3. [Working with tabular data using DataMatrix](%url:datamatrix%)\n4. [Plotting with Seaborn and Maplotlib](%url:plotting%)\n5. [Statistics with SciPy, Statsmodels, and Pingouin](%url:statistics%)\n6. [Analyzing time series with DataMatrix](%url:time-series%)",
    "title": "Introduction to data science with Python",
    "url": "https://pythontutorials.eu/numerical/introduction",
    "path": "content/pages/numerical/introduction.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Statistics: Exercises and Solutions\n\ntitle: Statistics: Exercises and Solutions\nnext_title: Statistics\nnext_url: %url:statistics%\n\n## Correlating activity in the left and right brain\n\n\n### Exercise\n\n- Read [this dataset](/data/fmri-data.npy), which has been adapted from the [StudyForrest](http://studyforrest.org/) project. See Exercise 2 from the [NumPy tutorial](%url:numpy%) if you don't remember this dataset!\n- Get the mean BOLD response over time, separately for the left and the right brain.\n- Plot the BOLD response over time for the left and the right brain.\n- You will notice that there is a slight drift in the signal, such that the BOLD response globally increases over time. You can remove this with so-called detrending, using `scipy.signal.detrend()`.\n- Plot the detrended BOLD response over time for the left and the right brain.\n- Determine the correlation between the detrended BOLD response in the left and the right brain.\n\nStatistical caveat: Measures that evolve over time, such as the BOLD response, are not independent. Therefore, statistical tests that assume independent observations are invalid for this kind of data! In this exercise, this means that the p-value for the correlation is not meaningful.\n\n\n\n### Solution\n\n```python\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom scipy.stats import linregress\nfrom scipy.signal import detrend\n\na = np.load('data/fmri-data.npy')\n# Get the average over the left and right brain across all dimensions\n# except time\nleft = a[:34].mean(axis=(0, 1, 2))\nright= a[34:].mean(axis=(0, 1, 2))\n# Detrend the signals and get the correlation between them\ndetrended_left = detrend(left)\ndetrended_right = detrend(right)\nslope, intercept, r, p, se = linregress(detrended_left, detrended_right)\nprint('r = {:.4f}'.format(r))\n# Create a nice plot!\nxdata = np.arange(0, 90, 10)\nplt.subplots_adjust(hspace=.4)\nplt.subplot(2, 1, 1)\nplt.plot(left, label='Left')\nplt.plot(right, label='Right')\nplt.xticks(xdata, 2 * xdata)\nplt.xlabel('Time')\nplt.xlim(0, 90)\nplt.ylabel('BOLD')\nplt.legend()\nplt.subplot(2, 1, 2)\nplt.plot(detrended_left)\nplt.plot(detrended_right)\nplt.xticks(xdata, 2 * xdata)\nplt.xlabel('Time')\nplt.xlim(0, 90)\nplt.ylabel('BOLD')\nplt.show()\n```",
    "title": "Statistics: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/statistics-solution-2",
    "path": "content/pages/numerical/statistics-solution-2.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# DataMatrix: Exercises and Solutions\n\ntitle: DataMatrix: Exercises and Solutions\nnext_title: DataMatrix\nnext_url: %url:datamatrix%\n\n\n```python\nfrom datamatrix import io\nfrom datamatrix import operations as ops\nfrom datamatrix import series as srs\n\ndm = io.readtxt('data/zhou_et_al_2020_exp1.csv')\nsm = ops.group(dm, dm.subject_nr)\nsm.mean_rt = srs.reduce_(sm.search_rt)\nsm = ops.keep_only(sm, sm.subject_nr, sm.mean_rt)\nlower = sm.mean_rt.mean - 2 * sm.mean_rt.std\nupper = sm.mean_rt.mean + 2 * sm.mean_rt.std\noutliers = (sm.mean_rt < lower) | (sm.mean_rt > upper)\nfor subject_nr in outliers.subject_nr:\n    print('Removing subject {}'.format(subject_nr))\n    dm = dm.subject_nr != subject_nr\n```",
    "title": "DataMatrix: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/datamatrix-solution-2",
    "path": "content/pages/numerical/datamatrix-solution-2.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Plotting: Exercises and Solutions\n\ntitle: Plotting: Exercises and Solutions\nnext_title: Plotting\nnext_url: %url:plotting%\n\n## Plotting heart-rate distributions in subplots\n\n### Exercise\n\nUse [this dataset](/data/heartrate.csv) from Moore, McCabe, & Craig to create a two-by-two plot, and in each subplot show the distribution of heart rate for one combination of gender and group of participants (Men Runners, Men Control, Female Runners, Female Control).\n\n\n\n### Solution\n\n\n```python\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nfrom datamatrix import io, operations as ops\n\ndm = io.readtxt('data/heartrate.csv')\nplt.subplot(2, 2, 1)\nplt.subplots_adjust(wspace=.4, hspace=.8)\nplt.title('Female Runners')\ndm_female_runner = (dm.Gender == 'Female') & (dm.Group == 'Runners')\nsns.distplot(dm_female_runner['Heart Rate'])\nplt.subplot(2, 2, 2)\nplt.title('Female Control')\ndm_female_control = (dm.Gender == 'Female') & (dm.Group == 'Control')\nsns.distplot(dm_female_control['Heart Rate'])\nplt.subplot(2, 2, 3)\nplt.title('Male Runners')\ndm_male_runner = (dm.Gender == 'Male') & (dm.Group == 'Runners')\nsns.distplot(dm_male_runner['Heart Rate'])\nplt.subplot(2, 2, 4)\nplt.title('Male Control')\ndm_male_control = (dm.Gender == 'Male') & (dm.Group == 'Control')\nsns.distplot(dm_male_control['Heart Rate'])\nplt.show()\n```",
    "title": "Plotting: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/plotting-solution-2",
    "path": "content/pages/numerical/plotting-solution-2.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Analyzing time series with DataMatrix\n\ntitle: Analyzing time series with DataMatrix\n\n\n[TOC]\n\n\n## What are time series?\n\nSay that you have a group of children. For each child, you write down his or her name and height. The result is a simple dataset of the kind that we've seen before, which you can represent as a spreadsheet with two columns (name and height) and one row for each child. You could plot this dataset as a simple bar plot (see %FigHeight::a).\n\nNow say that you measure the height of these children once a month for a year. The dataset now has a different structure, because for each name you now have twelve height values. Data of this kind is often called a time series, because it commonly (but not only) occurs for data sets in which some measure is tracked over time. You could plot this dataset as a line plot where the x-axis corresponds to time, the y-axis corresponds to height, and different lines correspond to different children (see %FigHeight::b).\n\n%--\nfigure:\n id: FigHeight\n source: height.png\n--%\n\nOther examples of time series are:\n\n- Historical data from stock exchanges. Here, each company has a time series associated with it that reflects how the company's share price has changed over time.\n- Heart-rate data from an experiment in which heart rate was measured over time for a group of participants (as opposed to being aggregated into a single average heart-rate value per participant). Here, each participant has a time series associated with it that reflects how that participant's heart rate changed over time.\n\n\n## Libraries for working with time series\n\nIn this chapter, we will use the datamatrix `SeriesColumn`, which is a type of column in which each cell is itself a series of values. This chapter assumes that you've already followed the basic [DataMatrix](%url:datamatrix) chapter earlier in this series on data science.\n\nFor a list of functions for working with series columns, see the datamatrix documentation:\n\n- <https://pydatamatrix.eu/series/>\n\nAnother commonly used library for working with time series is Pandas, which provides the [`pandas.Series` class](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html). We will not use Pandas for this tutorial.\n\n\n## Loading data\n\nIn this chapter, we will analyze the per-capita gross domestic product (GDP) for several European countries in the period 2000 - 2021. Per-capita GDP reflects how many paid services and goods were on average produced by a single person in that country; this is a rough indicator of a country's wealth, although it suffers from many imperfections, such as that services that are provided for (almost) free by the state are largely disregarded.\n\nThis data comes originally from [EuroStat](https://ec.europa.eu/eurostat/web/main/home), where you can find the raw data as 'Real GDP per capita'. But I have reformatted it slightly for this chapter. You can download the reformatted data [here](/data/eurostat-gdp.csv).\n\nLet's start by loading in the data and printing it out to explore its structure:\n\n\n```python\nfrom datamatrix import io\n\ndm = io.readtxt('data/eurostat-gdp.csv')\nprint(dm)\n```\n\nRight now, the structure of the data is such that there is one row for every country and every year, and per-capita GDP is represented as a single value. For example, the first row shows that the per-capita GDP for Albania (`AL`) in the year 2000 was \u20ac1700.\n\n\n## Dealing with invalid data\n\nPer-capita GDP values in this dataset are integers. This means that everything that is not an `int` is invalid data. Let's see what we get if we select those rows in which `dm.gdp` is not of type `int`:\n\n```python\nprint(dm.gdp != int)\n```\n\nOk, that's useful to know! The per-capita GDP of Romania (RO) in the years 2000 and 2001 is indicated by an empty string. This will cause problems later, because an empty string is not a number. In other words, for our purpose these two values are invalid data. To deal with this, we change these two values to `NAN`, which is a numerical (`float`) value that indicates missing data in a way that most numerical libraries know how to deal with.\n\n```python\nfrom datamatrix import NAN\n\ndm.gdp[dm.gdp != int] = NAN\n```\n\nNow that our data contains only numbers, we can plot it as a simple line plot. Admittedly, this plot is not very useful, because it plots all per-capita GDP values as a single line, without indicating which values belong to which countries and which years. Do you see the discontinuity around 620 on the x-axis? Those are the two `NAN` values that we inserted into the data above.\n\n```python\nfrom matplotlib import pyplot as plt\n\nplt.plot(dm.gdp)\nplt.show()\n```\n\n\n<div class=\"exercise\" markdown=\"1\">\n#### Mini exercise\n\nInstead of changing empty strings in the `gdp` column to `NAN` values, remove those rows from the datamatrix altogether.\n</div>\n\n\n## Restructuring data as a time series\n\nAt this point, while our data is conceptually a time series, it is still represented as a regular two-dimensional spreadsheet. We can do better! Let's restructure the data into a more convenient format. Specifically, each row should correspond to a single country; this means that each row will have multiple values for year and GDP, because both of these are time series associated with countries, in the same way that height was a time series associated with names in %FigHeight::b.\n\nThis restructuring is done by the `group()` function from the `datamatrix.operations` module. This function takes a datamatrix and one or more columns from this datamatrix to group by. In our case, we group by country and print out the resulting datamatrix, which we call `sm`, to explore the new structure:\n\n\n```python\nfrom datamatrix import operations as ops\n\nsm = ops.group(dm, by=dm.country)\nprint(sm)\nprint(f'Each country has {sm.gdp.depth} values for GDP')\nprint(f'Each country has {sm.year.depth} values for year')\n```\n\nBoth `gdp` and `year` are a special type of column (`SeriesColumn` objects) that has been designed to represent time series. Specifically, in a series column a single cell doesn't contain a single value, as is the case for regular columns such as `country`, but rather contains multiple values. The `depth` property of a series column indicates how many values there are in each cell. In our case, the depth of the `gdp` and `year` columns is 22, which makes sense because our dataset spans 22 years (2000 until and including 2021).\n\nWe can now plot our dataset in a more useful way by creating a line plot in which the x-axis reflects time (imperfectly for now!) and each line corresponds to a single country. (The `plottable` property of a series column provides the time-series data in a format that `plt.plot()` understands.)\n\n\n```python\nplt.plot(sm.gdp.plottable)\nplt.show()\n```\n\n<div class=\"exercise\" markdown=\"1\">\n#### Mini exercise\n\nCreate a plot like the one above, but with only data from the Scandinavian countries: Denmark (DK), Norway (NO), Sweden (SE), Finland (FI), and Iceland (IS).\n</div>\n\n\n## Understanding the structure of time series\n\n\nA few notes to avoid confusion:\n\nThe length of a series column (`len(sm.gdp)`) is equal to the length of the datamatrix and thus reflects the number of rows. The depth of a series column reflects the number of values (or: samples, time points, observations, etc.) in the time series.\n\nYou can think of a series column as having 3 dimensions, as opposed to the 2 dimensions of a regular column.\n\n- The first dimension is the column name; this works the same as for a regular column\n- The second dimension is the row number; this works the same for a regular column\n- The third dimension is the sample number within the series; this is unique for series columns\n\nLet's consider some examples. The first row (0) of `gdp` is a numpy array. This array reflect how `gdp` changes over the years for the country corresponding to the first row.\n\n```python\nprint(sm.country[0])\nprint(sm.gdp[0])\n```\n\nThe last value (-1) from the first row (0) of `gdp` is a single value. This value reflects the per-capita GDP in the last year of the time series (2021) for the country corresponding to the first row.\n\n```python\nprint(sm.country[0])\nprint(sm.gdp[0, -1])\n```\n\nThe last value (-1) from all rows (`:`) is a column. This column reflects the per-capita GDP in the last year of the time series (2021) for all rows.\n\n```python\nprint(sm.country[:])\nprint(sm.gdp[:, -1])\n```\n\n<div class=\"exercise\" markdown=\"1\">\n#### Mini exercise\n\nPrint out the per-capita GDP for France (FR) in the years 2006 through 2010.\n</div>\n\n\n\n## Dealing with missing data\n\nThe dataset spans the years 2000 until and including 2021. However, data is not available for all countries for all years. Specifically, for some countries data is missing for the first few years. We've already seen an example of this above, when we recoded the invalid data for Romania for 2000 and 2001. But for a few other countries, some data is simply missing altogether, not even represented by empty strings.\n\nThis is characteristic of real-world time-series data: data is often incomplete in multiple ways, and it's therefore important to check your data carefully.\n\nLet's first print out the first value (`0`) of the `year` column for all (`:`) countries:\n\n```python\nprint(sm.year[:, 0])\n```\n\nMost values are 2000, indicating that GDP values are available from 2000 onwards. However, there is one exception: 2006. So what country corresponds to this exception?\n\n```python\nprint(sm.year[:, 0] != 2000)\n```\n\nIt's Montenegro (ME), which declared independence from Serbia in 2006.\n\nThe fact that the first `gdp` value for Montenegro corresponds to 2006, whereas the first value for all other countries corresponds to 2000, means that the data is misaligned. So how can we re-align the data?\n\nImagine that we take the time series for Montenegro, as shown above, and shift all values to the right by 6 positions, thus compensating for the six missing years at the start. The values that fall off the end, which are all `NAN`, should then wrap around so that they move to the start of the series. This is exactly what the `roll()` function from `datamatrix.series`  does!\n\nWe can pass a single `shift` value to `roll()`, in which case all rows are shifted by the same amount. But that's not what we want here, because we want to shift the row corresponding to Montenegro by 6, whereas we don't want to shift the other rows at all. Fortunately, `roll()` can also takes a sequence of values for the `shift` parameter so that each row can be shifted by a different amount.\n\nIn our case, for each row, the shift value is equal to the first value of the `year` series minus 2000. For Montenegro, this results in 6, because the `year` series starts at 2006 (2006 - 2000 = 6). For all other countries, this results in 0, because the `year` series starts at 2000 (2000 - 2000 = 0). We apply `roll()` to both the `gdp` and `year` series:\n\n```python\nfrom datamatrix import series as srs\n\nshift = sm.year[:, 0] - 2000\nprint(shift)\nsm.year = srs.roll(sm.year, shift)\nsm.gdp = srs.roll(sm.gdp, shift)\nprint(sm)\n```\n\n\n<div class=\"exercise\" markdown=\"1\">\n#### Mini exercise\n\nCreate a new column that indicates, for each country separately, the number of years for which data is missing. To do this, you can use the `nancount()` function from `datamatrix.series`.\n</div>\n\n\n## Visualizing and summarizing\n\nWe can now create a similar plot to the one that we created before, but this time our visualization is accurate because we have properly aligned the data. We can also add a legend so that we can tell which line corresponds to which country. And we can plot a thick black line to indicate the mean per-capita GDP across countries (`sm.gdp.mean`).\n\n```python\nplt.figure(figsize=(11, 11))\nplt.plot(sm.gdp.plottable, label=sm.country)\nplt.plot(sm.gdp.mean, color='black', linewidth=5)\nplt.xticks(range(0, 22, 2), range(2000, 2022, 2))\nplt.xlabel('Year')\nplt.ylabel('Per-capita GDP (\u20ac)')\nplt.legend(title='Country', bbox_to_anchor=(1, 1))\nplt.show()\n```\n\nThe plot above is a bit overwhelming, but it does highlight some general patterns. Notably, GDP tends to increase over time, with the exception of the years following the 2008 financial crisis and a brief dip in 2020 related to the corona epidemic.\n\nLet's simplify the data to getter a better picture. Specifically, let's get the mean per-capita GDP over the 2000 - 2021 period for each country separately. We can use the `reduce()` function from `datamatrix.series` to do this. To 'reduce' is a somewhat technical term for the general concept of taking a series of values and 'reducing' it to a single value. By default, this happens by taking the mean.\n\nTo avoid confusion: `srs.reduce(sm.gdp)` gives the mean per-capita GDP for each country averaged over years, whereas `sm.gdp.mean` (which we used above for plotting) gives the mean GDP for each year averaged over countries.\n\nFinally, we sort the datamatrix by mean per-capita GDP so that the resulting plot is rank-ordered and thus even easier to understand.\n\n```python\nsm.mean_gdp = srs.reduce(sm.gdp)\nsm = ops.sort(sm, by=sm.mean_gdp)\nplt.figure(figsize=(11, 4))\nplt.plot(sm.country, sm.mean_gdp, 'o')\nplt.xlabel('Country')\nplt.ylabel('Mean per-capita GDP 2000 - 2021 (\u20ac)')\nplt.show()\n```\n\nThis plot shows extreme differences in per-capita GDP between countries, ranging from \u20ac2,914 in Albania to \u20ac81,739 in Luxembourg. To some extent these differences reflect actual differences in wealth. But they also reflect whether or not a country has a large banking system (Luxembourg being an extreme example), because moving money around adds to the GDP just as much as producing physical products does.\n\nFinally, let's look at the per-capita GDP growth rate, which requires a slightly more complex reduce operation. As mentioned above, `reduce()` by default takes the mean of a series across time. However, you can also specify a different operation by passing a custom function through the `operation` keyword. This function should accept a 1D array as a sole argument and return a single value. In our case, the 1D array corresponds to all per-capita GDP values over time for a single country; that is, the reduce operation is done per country.\n\nTo determine the per-capita GDP growth rate, we can define a custom reduce function, `get_slope()`, that performs a linear regression on the GDP values for each country, and returns the slope of the regression line. Internally, this function uses `linregress()` from `scipy.stats`, which cannot handle `NAN` values; therefore, we need to exclude those.\n\n```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef get_slope(y):\n    y = y[~np.isnan(y)]    # only keep numeric (non-NAN) values\n    x = np.arange(len(y))  # define x values\n    slope, intercept, r, p, se = linregress(x, y)\n    return slope\n\nsm.gdp_growth = srs.reduce(sm.gdp, operation=get_slope)\n```\n\nNow we can create a scatter plot with mean GDP on the x-axis and GDP growth rate on the y-axis.\n\n```python\nplt.axhline(0, linestyle=':', color='black')\nplt.plot(sm.mean_gdp, sm.gdp_growth, 'o')\nplt.xlabel('Mean per-capita GDP 2000 - 2021 (\u20ac)')\nplt.ylabel('Per-capita GDP growth rate 2000 - 2021 (\u20ac)')\nplt.show()\n```\n\nMost countries show moderate positive growth. However, two countries, those corresponding to the two points below the dotted line, show negative growth. And one country shows extremely rapid growth. Which countries are those?\n\n```python\nsm_extremes = (sm.gdp_growth < 0) | (sm.gdp_growth > 1000)\nplt.figure(figsize=(11, 5))\nplt.plot(sm_extremes.gdp.plottable, label=sm_extremes.country)\nplt.xticks(range(0, 22, 2), range(2000, 2022, 2))\nplt.xlabel('Year')\nplt.ylabel('Per-capita GDP (\u20ac)')\nplt.legend(title='Country', bbox_to_anchor=(1, 1))\nplt.show()\n```\n\nThe shrinking per-capita GDPs correspond to Greece (EL) and Italy (IT), neither of which really recovered from the 2008 financial crisis. The rapidly expanding economy corresponds to Ireland (IE), which due to attractive tax schemes is the European financial home for many multinationals; the creative bookkeeping of those multinationals makes the Irish per-capita GDP particularly volatile.\n\n\n## Review exercise\n\n<div class='info-box' markdown=1>\n\n### The impact of crises\n\nTake the datamatrix (`sm`) that you have constructed during this chapter. During the period that this dataset spans, two major crises occurred: the 2008 financial crisis and the 2020 corona crisis.\n\nFirst, quantify the impact of both crises on the per-capita GDP of each country. For the 2008 financial crisis, the impact can be quantified as the difference between per-capita GDP in 2009 and 2007. For the corona crisis, the impact can be quantified as the difference between 2020 and 2019.\n\nNext, create a scatter plot with the 2008-crisis impact on the x-axis, the corona-crisis impact on the y-axis, and individual countries as points. Draw dotted black lines (one horizontal and one vertical) through the 0 points for both axes. Draw solid red lines (one horizontal and one vertical) to indicate the mean impact of each crisis across countries.\n\n\n[View solution](%url:time-series%-solution-1)\n\n</div>",
    "title": "Analyzing time series with DataMatrix",
    "url": "https://pythontutorials.eu/numerical/time-series",
    "path": "content/pages/numerical/time-series.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# DataMatrix: Exercises and Solutions\n\ntitle: DataMatrix: Exercises and Solutions\nnext_title: DataMatrix\nnext_url: %url:datamatrix%\n\n\n```python\nfrom datamatrix import io\n\ndm = io.readxlsx('data/movies.xlsx')\ndm = (dm.year >= 1990) & (dm.year < 2000)\nfor year in dm.year.unique:\n    year_dm = dm.year == year\n    print('For movies from year {}, the mean rating is {:.2f}'.format(\n        year,\n        year_dm.rating.mean\n    ))\n```\n\nAn alternative solution makes use of `datamatrix.operations.split()`:\n\n```python\nfrom datamatrix import io\nfrom datamatrix import operations as ops\n\ndm = io.readxlsx('data/movies.xlsx')\ndm = (dm.year >= 1990) & (dm.year < 2000)\nfor year, year_dm in ops.split(dm.year):\n    print('For movies from year {}, the mean rating is {:.2f}'.format(\n        year,\n        year_dm.rating.mean\n    ))\n```",
    "title": "DataMatrix: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/datamatrix-solution-1",
    "path": "content/pages/numerical/datamatrix-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# NumPy: Exercises and Solutions\n\ntitle: NumPy: Exercises and Solutions\nnext_title: numpy\nnext_url: %url:numpy%\n\n\n## Activity in the left vs right brain\n\n### Exercise\n\n- Read [this dataset](/data/fmri-data.npy), which has been adapted from the [StudyForrest](http://studyforrest.org/) project. It is an `.npy` file, which you can read with `np.load()`.\n- This will give you a 4D array with the following dimensions: left-to-right, back-to-front, bottom-to-top, time (1 sample per 2 s). Values in the array correspond to BOLD values (an indirect measure of brain activity).\n- First, inspect the shape of the array to see how big each dimension is.\n- Next, print out the average BOLD value separately for the left and the right side of the brain!\n\n\n\n### Solution\n\n```python\nimport numpy as np\n\na = np.load('data/fmri-data.npy')\nprint(a.shape)\nm_left = a[:34].mean()\nm_right= a[34:].mean()\nprint('M(left) = {:.2f}'.format(m_left))\nprint('M(right) = {:.2f}'.format(m_right))\n```",
    "title": "NumPy: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/numpy-solution-2",
    "path": "content/pages/numerical/numpy-solution-2.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Statistics with SciPy, Statsmodels, and Pingouin\n\ntitle: Statistics with SciPy, Statsmodels, and Pingouin\nnext_title: Time series\nnext_url: %url:time-series%\n\n[TOC]\n\n\n## Libraries for statistics\n\n\n### SciPy\n\n[SciPy](https://www.scipy.org/) is a Python package with a large number of functions for numerical computing. It also contains statistical functions, but only for basic statistical tests (t-tests etc.).\n\n\n### Statsmodels\n\nMore advanced statistical tests are provided by [Statsmodels](https://www.statsmodels.org/stable/index.html). Statsmodels is powerful, but not very user-friendly; therefore, the tutorial below shows examples of several commonly used statistical tests.\n\n\n### Pingouin\n\n[Pingouin](https://pingouin-stats.org/) is a relatively new Python library for statistics. It provides more uniform and user-friendly functions than SciPy and Statsmodels.\n\n\n## Example datasets\n\nAll datasets used below are taken from the example data included with [JASP](https://jasp-stats.org/), with the exception of the [Zhou et al. (2020) dataset](https://doi.org/10.3758/s13414-020-02048-5) used for the Repeated Measures ANOVA.\n\n\n## T-tests\n\n### Independent-samples t-test\n\nConsider [this dataset](/data/matzke_et_al.csv) from Matzke et al. (2015). In this dataset, participants performed a memory task in which they recalled a list of words. During the retention interval, one group of participants looked at a central fixation dot on a display. Another group of participants continuously made horizontal eye movements, which is believed by some to improve memory.\n\nYou can use the `ttest_ind()` function from `scipy.stats` to test whether memory performance (`CriticalRecall`) was higher for the horizontal-eye-movement group as compared to the fixation group.\n\n\n```python\nfrom datamatrix import io, operations as ops\nfrom scipy.stats import ttest_ind\n\ndm = io.readtxt('data/matzke_et_al.csv')\ndm_horizontal, dm_fixation = ops.split(dm.Condition, 'Horizontal', 'Fixation')\nt, p = ttest_ind(dm_horizontal.CriticalRecall, dm_fixation.CriticalRecall)\nprint('t = {:.4f}, p = {:.4f}'.format(t, p))\n```\n\nThis reveals a significant difference (*p* = .0066). However, as you can see in the figure below, the effect goes in the opposite direction from the prediction, such that the fixation group performed best.\n\nYou can also use the `ttest()` function from `pingouin`. This also provides a Bayes Factor, for those who are into Bayesian statistics.\n\n```python\nimport pingouin as pg\n\ndf = pg.ttest(dm_horizontal.CriticalRecall, dm_fixation.CriticalRecall)\nprint(df)\n```\n\nIt's always helpful to visualize the results:\n\n```python\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nsns.barplot(x='Condition', y='CriticalRecall', data=dm)\nplt.xlabel('Condition')\nplt.ylabel('Memory performance')\nplt.show()\n```\n\n\n### Paired-samples t-test\n\nConsider [this dataset](/data/moon-aggression.csv) from Moore, McCabe, & Craig. Here, aggressive behavior from people suffering from dementia was measured during full moon and another phase of the lunar cycle. Each participant was measured at both phases, i.e. this was a within-subject design.\n\nYou can use the `ttest_rel()` function to test whether aggression differed between the full moon and the other lunar phase.\n\n\n```python\nfrom datamatrix import io\nfrom scipy.stats import ttest_rel\n\ndm = io.readtxt('data/moon-aggression.csv')\nt, p = ttest_rel(dm.Moon, dm.Other)\nprint('t = {:.4f}, p = {:.4f}'.format(t, p))\n```\n\nInterestingly, there was indeed a significant effect (*p* < .0001; note that *p* values are never 0 as the output implies!), and this effect was in such that people were indeed most aggressive during full moon, as you can see in the figure below.\n\nYou can also use the `ttest()` function from `pingouin` and use the `paired` keyword to indicate that this is a paired-samples t-test, as opposed to an independent-samples t-test.\n\n```python\nimport pingouin as pg\n\ndf = pg.ttest(dm.Moon, dm.Other, paired=True)\nprint(df)\n```\n\nAnd let's visualize the result. Because the measurements of the data are in two separate columns, we cannot easily use Seaborn for plotting. But we can resort to a quick plot with `plt.plot()`.\n\n```python\nfrom matplotlib import pyplot as plt\n\nplt.plot([dm.Moon.mean, dm.Other.mean], 'o-')\nplt.xticks([0, 1], ['Moon', 'Other'])\nplt.ylabel('Aggression')\nplt.xlabel('Lunar phase')\nplt.show()\n```\n\n### One-sample t-test\n\nIf we take the difference between the Moon and Other measurements of [the above dataset](/data/moon-aggression.csv), then we can test this difference against zero (or another value specified with the `popmean` keyword) with `ttest_1samp()`:\n\n```python\nfrom datamatrix import io\nfrom scipy.stats import ttest_1samp\n\ndm = io.readtxt('data/moon-aggression.csv')\ndiff = dm.Moon - dm.Other\nt, p = ttest_1samp(diff, popmean=0)\nprint('t = {:.4f}, p = {:.4f}'.format(t, p))\n```\n\nYou can also use the `ttest()` function from `pingouin`. To indicate that this is a one-sample t-test against zero, simply pass 0 as the second argument.\n\n```python\nimport pingouin as pg\n\ndf = pg.ttest(diff, 0)\nprint(df)\n```\n\n## Regression\n\n### Correlation / simple linear regression\n\n[This dataset](/data/adam-sandler.csv), taken from Rotten Tomatoes, contains the 'freshness' rating and the Box Office profit for all of Adam Sandler's movies. You can use `linregress()` from `scipy.stats` to test if highly rated Adam Sandler movies make more money than poorly rated ones.\n\n```python\nfrom datamatrix import io\nfrom scipy.stats import linregress\n\ndm = io.readtxt('data/adam-sandler.csv')\nslope, intercept, r, p, se = linregress(dm.Freshness, dm['Box Office ($M)'])\nprint('Box Office = {:.2f} * Freshness + {:.2f}'.format(slope, intercept))\nprint('p = {:.4f}, r = {:.4f}'.format(p, r))\n```\n\nThere seems to be no notable relationship between the freshness ratings of Adam Sandler's movies and their Box Office profit (*p* = .8785), as you can also see in the figure below.\n\nYou can also use the `linear_regression()` function from `pingouin`. Here, the intercept and slope simply correspond to the first and second values in the `coef` column.\n\n```python\nimport pingouin as pg\n\ndf = pg.linear_regression(X=dm.Freshness, y=dm['Box Office ($M)'])\nprint(df)\n```\n\nTo get the correlation, you can use the `corr` function from `pingouin`.\n\n```python\ndf = pg.corr(dm.Freshness, dm['Box Office ($M)'])\nprint(df)\n```\n\nTo visualize this relationship, you can use Seaborn's `regplot()` function.\n\n\n```python\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nsns.regplot(x='Freshness', y='Box Office ($M)', data=dm)\nplt.show()\n```\n\n\n### Multiple linear regression\n\nConsider [this dataset](/data/gpa.csv) from Moore, McCabe, & Craig which contains grade-point averages (`gpa`) and SAT scores for mathematics (`satm`) and verbal knowledge (`satv`) for 500 high-school students. To test whether `satm` and `satv` are (uniquely) related to `gpa`, you can use the code below.\n\nThe series of function calls (`model = ols(\u2026).fit()` and then `model.summary()`) isn't very elegant, but the important part is the formula that is specified in a string with an R-style formula.\n\n```python\nfrom datamatrix import io\nfrom statsmodels.formula.api import ols\n\ndm = io.readtxt('data/gpa.csv')\nmodel = ols('gpa ~ satm + satv', data=dm).fit()\nprint(model.summary())\n```\n\nThis reveals that only SAT scores for mathematics (*t* = 3.444, *p* = .001), but not for verbal knowledge (*t* = -0.040, *p* = .968), are uniquely related to grade point average.\n\nYou can also use the `linear_regression()` function from `pingouin`. The first argument, `X`, now consists of multiple columns (as opposed to a single column when doing a simple linear regression). To select the columns that should be used as predictors, you can simply select them directly from the datamatrix (`dm['satm', 'satv']`).\n\n```python\nimport pingouin as pg\n\ndf = pg.linear_regression(X=dm['satm', 'satv'], y=dm.gpa)\nprint(df)\n```\n\n\n## ANOVA\n\n### ANOVA (regular)\n\nLet's go back to [this heart-rate data](/data/heartrate.csv) from Moore, McCabe, and Craig. This dataset contains two factors that vary between subjects (Gender and Group) and one dependent variable (Heart Rate). To test whether Gender, Group, or their interaction affect heart rate, you need the following code.\n\nAs above, the combination of `ols()` and `anova_lm()` isn't very elegant, but the important part is the formula.\n\n```python\nfrom datamatrix import io\nfrom statsmodels.formula.api import ols\nfrom statsmodels.stats.anova import anova_lm\n\ndm = io.readtxt('data/heartrate.csv')\ndm.rename('Heart Rate', 'HeartRate')  # statsmodels doesn't like spaces\ndf = anova_lm(ols('HeartRate ~ Gender * Group', data=dm).fit())\nprint(df)\n```\n\nThis reveals that heart rate is related to all factors: gender (*F* = 185.980, *p* < .001), group (*F* = 695.647, *p* < .001), and the gender-by-group interaction (*F* = 7.409, *p* = .006).\n\nYou can also use the `anova` function from `pingouin`.\n\n```python\nimport pingouin as pg\n\naov = pg.anova(dv='HeartRate', between=['Gender', 'Group'], data=dm)\nprint(aov)\n```\n\nYou can visualize this result with Seaborn:\n\n```python\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nsns.pointplot(x='Group', y='HeartRate', hue='Gender', data=dm)\nplt.xlabel('Group')\nplt.ylabel('Heart rate')\nplt.show()\n```\n\n### Repeated Measures ANOVA\n\nA Repeated Measures ANOVA is generally used to analyze data from experiments in which all participants take part in all conditions, that is, a within-subject design. An example of such a design comes from an experiment by [Zhou and colleagues](https://doi.org/10.3758/s13414-020-02048-5), in which participants searched for a target object in the presence of a distractor object. Either the target, or the distractor, or both could match a color that participants held in memory. You can download [this dataset here](/data/zhou_et_al_2020_exp1.csv).\n\nTo test whether the factors distractor-match, target-match, and their interaction affect search accuracy, you can use the `AnovaRM` class from `statsmodels.stats.anova`.\n\nSomewhat different most other RM-ANOVA software, the `AnovaRM` class accepts the data in long, unaggregated format. That is, each row corresponds to a single observation. Statsmodels will automatically reduce this format to a format where observations are aggregated per participant and condition (which is the required format for an RM-ANOVA) using the method indicated with the `aggregate_func` keyword:\n\n\n```python\nfrom datamatrix import io\nfrom statsmodels.stats.anova import AnovaRM\n\ndm = io.readtxt('data/zhou_et_al_2020_exp1.csv')\naov = AnovaRM(\n    dm,\n    depvar='search_correct',\n    subject='subject_nr',\n    within=['target_match', 'distractor_match'],\n    aggregate_func='mean'\n).fit()\nprint(aov)\n```\n\nThis reveals that search accuracy is affected by all factors: target match (*F* = 6.7339, p = .0139), distractor match (*F* = 13.9729, *p* = .0007), and the target match by distractor match interaction (*F* = 7.1687, *p* = .0113).\n\nYou can also use the `rm_anova` function from `pingouin`.\n\n\n```python\nimport pingouin as pg\n\naov = pg.rm_anova(\n    dv='search_correct',\n    within=['target_match', 'distractor_match'],\n    subject='subject_nr',\n    data=dm\n)\nprint(aov)\n```\n\nLet's visualize this result.\n\nWe could (but shouldn't!) simply create a `pointplot` based on `dm`. But this plot would not take into account that a Repeated Measures ANOVA is based on aggregated data (i.e. one observation per condition and participant). And therefore the error bars of this plot would not reflect the variation between participants (as it should), but rather the variation between individidual trials. \n\nTo make a more appropriate figure, we first use `ops.group()` to create a new datamatrix, `gm`, in each row corresponds to a single condition for a single participant. Initially, `gm.search_correct` then corresponds to a series of values, one for each trial. (It is a `SeriesColumn`, a powerful type of column about which you can read more [here](https://pydatamatrix.eu/series-tutorial/).) We use `srs.reduce_()` to change this series of values to a single, mean value. Finally, we remove the between-subject variability, which is a fancy way of saying that we change `search_correct` such that it is on average the same for each participant, without changing the overall average of `search_correct` across participants. (This procedure is described in more detail in [this blogpost](https://www.cogsci.nl/blog/tutorials/156-an-easy-way-to-create-graphs-with-within-subject-error-bars).)\n\nAnd then we can finally create a plot that is an appropriate match to the Repeated Measures ANOVA!\n\n\n```python\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nfrom datamatrix import operations as ops, series as srs\n\n# Group the data by condition and subject\ngm = ops.group(\n    dm,\n    by=[dm.target_match, dm.distractor_match, dm.subject_nr]\n)\ngm.search_correct = srs.reduce_(gm.search_correct)\n# Remove between-subject variability\nfor subject_nr, sm in ops.split(gm.subject_nr):\n    gm.search_correct[sm] = sm.search_correct - sm.search_correct.mean + gm.search_correct.mean\n# And plot!\nsns.pointplot(\n    x='target_match',\n    y='search_correct',\n    hue='distractor_match',\n    data=gm\n)\nplt.xlabel('Target match')\nplt.ylabel('Search accuracy (proportion)')\nplt.legend(title='Distractor match')\nplt.show()\n```\n\nTip: If you prefer to conduct the RM-ANOVA with different software, such as JASP or SPSS, then you first need to create a so-called pivot table, in which each row corresponds to a subject, and each column to a condition. You can do this with the `ops.pivot_table()` function:\n\n```python\npm = ops.pivot_table(\n    dm,\n    values=dm.search_correct,\n    index=dm.subject_nr,\n    columns=[dm.target_match, dm.distractor_match]\n)\nprint(pm)\n```\n\n\n## Linear mixed-effects modeling\n\nA linear mixed-effects model (or: linear mixed-effects regression) is a modern statstical-analysis technique for 'hierarchical' datasets. This sounds complicated, but the most common type of hierarchy is simply a dataset that consists of multiple observations from multiple participants. The Zhou et al. dataset, described [above](#repeated-measures-anova), is an example of such a dataset.\n\nIn many cases, you can analyze the same dataset using either a Repeated Measures ANOVA or a linear mixed-effects model; however, one crucial difference is that a Repeated Measures ANOVA requires you to aggregate data across multiple observations (e.g. by calculating the mean reaction time per participant and condition), whereas a linear mixed-effects model is performed on unaggregated data, i.e. on individual observations. In addition, linear mixed-effects modeling offers far more flexibility for analyzing complex datasets that you cannot analyze with a Repeated Measures ANOVA.\n\nLet's say that we want to analyze search reaction times as a function of the conditions target match and distractor match, and that we want to have random by-participant intercepts and slopes. The most well-known package for linear mixed-effects modeling is the R package `lme4`, in which case this analysis corresponds to the formula:\n\n```R\nsearch_rt ~ target_match * distractor_match + (1 + target_match * distractor_match | subject_nr)\n```\n\nIn Python, we need to use `statsmodels` for this, and the syntax is slightly different. Notably, the random effects structure is passed separately as the `re_formula` keyword:\n\n```python\nfrom datamatrix import io\nfrom statsmodels.formula.api import mixedlm\n\ndm = io.readtxt('data/zhou_et_al_2020_exp1.csv')\nmodel = mixedlm(formula='search_rt ~ target_match * distractor_match',\n                re_formula='~ target_match * distractor_match',\n                data=dm, groups='subject_nr').fit()\nprint(model.summary())\n```\n\nThis reveals that search reaction times are affected by all factors: target match (*z* = -6.579, *p* < .001), distractor match (*z* = 5.230, *p* < .001), and the target match by distractor match interaction (*z* = 2.492, *p* = .013).\n\n\n## Exercises\n\n<div class='info-box' markdown=1>\n\n### A three-way Repeated Measures ANOVA\n\nAbove you have seen how to conduct a two-way repeated measures ANOVA with [this dataset](/data/zhou_et_al_2020_exp1.csv) from Zhou et al. (2020). But the data contains a third factor: congruency. First, run a three-way repeated measures ANOVA with target-match, distractor-match, and congruency as independent variables, and search accuracy as dependent variable. Next, plot the results in a two-panel plot, where the left subplot shows the effect of distractor and target match for congruent trials, while the right subplot shows this for incongruent trials.\n\n\n[View solution](%url:statistics%-solution-1)\n\n</div>\n\n<div class='info-box' markdown=1>\n\n### Correlating activity in the left and right brain\n\n- Read [this dataset](/data/fmri-data.npy), which has been adapted from the [StudyForrest](http://studyforrest.org/) project. See Exercise 2 from the [NumPy tutorial](%url:numpy%) if you don't remember this dataset!\n- Get the mean BOLD response over time, separately for the left and the right brain.\n- Plot the BOLD response over time for the left and the right brain.\n- You will notice that there is a slight drift in the signal, such that the BOLD response globally increases over time. You can remove this with so-called detrending, using `scipy.signal.detrend()`.\n- Plot the detrended BOLD response over time for the left and the right brain.\n- Determine the correlation between the detrended BOLD response in the left and the right brain.\n\nStatistical caveat: Measures that evolve over time, such as the BOLD response, are not independent. Therefore, statistical tests that assume independent observations are invalid for this kind of data! In this exercise, this means that the p-value for the correlation is not meaningful.\n\n\n[View solution](%url:statistics%-solution-2)\n\n</div>",
    "title": "Statistics with SciPy, Statsmodels, and Pingouin",
    "url": "https://pythontutorials.eu/numerical/statistics",
    "path": "content/pages/numerical/statistics.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Statistics: Exercises and Solutions\n\ntitle: Statistics: Exercises and Solutions\nnext_title: Statistics\nnext_url: %url:statistics%\n\n\n## A three-way Repeated Measures ANOVA\n\n\n### Exercise\n\nAbove you have seen how to conduct a two-way repeated measures ANOVA with [this dataset](/data/zhou_et_al_2020_exp1.csv) from Zhou et al. (2020). But the data contains a third factor: congruency. First, run a three-way repeated measures ANOVA with target-match, distractor-match, and congruency as independent variables, and search accuracy as dependent variable. Next, plot the results in a two-panel plot, where the left subplot shows the effect of distractor and target match for congruent trials, while the right subplot shows this for incongruent trials.\n\n\n\n### Solution\n\n```python\nfrom pandas import pivot_table\nfrom datamatrix import io\nfrom datamatrix import operations as ops\nfrom statsmodels.stats.anova import AnovaRM\nimport seaborn as sns\n\n# Read the data and pass it to AnovaRM\ndm = io.readtxt('data/zhou_et_al_2020_exp1.csv')\naov = AnovaRM(\n    dm,\n    depvar='search_correct',\n    subject='subject_nr',\n    within=[\n        'target_match',\n        'distractor_match',\n        'congruency'\n    ],\n    aggregate_func='mean'\n).fit()\nprint(aov)\n# Now plot the data!\ndm_congruent, dm_incongruent = ops.split(dm.congruency, 1, 0)\nplt.subplots_adjust(wspace=0.4)\nplt.subplot(1, 2, 1)\nplt.title('Congruent')\nsns.pointplot(\n    x='target_match',\n    y='search_correct',\n    hue='distractor_match',\n    data=dm_congruent\n)\nplt.ylim(0.75, 1)\nplt.xlabel('Target match')\nplt.ylabel('Search accuracy (proportion)')\nplt.legend(title='Distractor match')\nplt.subplot(1, 2, 2)\nplt.title('Incongruent')\nsns.pointplot(\n    x='target_match',\n    y='search_correct',\n    hue='distractor_match',\n    data=dm_incongruent\n)\nplt.ylim(0.75, 1)\nplt.xlabel('Target match')\nplt.ylabel('Search accuracy (proportion)')\nplt.legend(title='Distractor match')\nplt.show()\n```",
    "title": "Statistics: Exercises and Solutions",
    "url": "https://pythontutorials.eu/numerical/statistics-solution-1",
    "path": "content/pages/numerical/statistics-solution-1.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Customizing MobileNetV2 through transfer learning\n\ntitle: Customizing MobileNetV2 through transfer learning\n\n[TOC]\n\n\n## Customizing MobileNetV2\n\nIn [the previous tutorial](%link:image-classification%), you learned how to use MobileNetV2, a pretrained network for image classification. This is fun, but there are not many situations in which you want to perform the exact same task that MobileNetV2 has been trained on.\n\nTherefore, in this tutorial, you will learn how to modify and retrain MobileNetV2 to perform another task than the one it was trained on: distinguishing male and female cats. This is an example of *transfer learning*: using the fact that having already learned one task (image classification using a 1000 categories) makes it easier to learn another task (distinguishing male and female cats).\n\n\n## Importing MobileNetV2\n\nWe again start by loading MobileNetV2.\n\n```python\nfrom keras.applications.mobilenet_v2 import MobileNetV2\n\nmodel = MobileNetV2(weights='imagenet')\n```\n\n\n## Loading images and creating labels\n\nOur training data consists of 40 images: twenty pictures of male cats and twenty pictures of female cats. These pictures are taken from [this online experiment](http://www.chrislongmore.co.uk/experiments/catfaces/) by Chris Longmore. You can download the images [here](/data/cats.zip).\n\nWe first create an empty array of shape `(40, 224, 224, 3)`. This corresponds to 40 images of 224 \u00d7 224 pixels with three color channels.\n\n```python\nimport numpy as np\n\ndata = np.empty((40, 224, 224, 3))\n```\n\nI extracted the images to a subfolder called `data/cats`. The files are called `f01.jpg`, `f02.jpg` \u2026 `f20.jpg` for the female cats, and `m01.jpg` \u2026 `m20.jpg` for the male cats.\n\n%--\nfigure:\n    source: f06.jpg\n    id: FigFemaleCat\n    caption: A female cat.\n--%\n\n%--\nfigure:\n    source: m10.jpg\n    id: FigMaleCat\n    caption: A male cat.\n--%\n\nWe first read in the female cats, and put them in the first 20 places of the `data` array. Each image is first read, then preprocessed so that the pixel values are in the -1 to 1 range, then resized to 224 \u00d7 224, and finally assigned to the `data` array. (See [this previous tutorial](%link:image-classification%) if you're unsure how this works.)\n\n```python\nfrom imageio import imread\nfrom skimage.transform import resize\nfrom keras.applications.mobilenet_v2 import preprocess_input\n\nfor i in range(0, 20):\n    im = imread('data/cats/f{:02d}.jpg'.format(i + 1))\n    im = preprocess_input(im)\n    im = resize(im, output_shape=(224, 224))\n    data[i] = im\n```\n\nNext we read in the male cats, and put them in the last 20 places of the `data` array:\n\n```python\nfor i in range(0, 20):\n    im = imread('data/cats/m{:02d}.jpg'.format(i + 1))\n    im = preprocess_input(im)\n    im = resize(im, output_shape=(224, 224))\n    data[i + 20] = im\n```\n\nThe training labels correspond to an array of length 40, where the first 20 values are 0 and the last 20 values are 1. In other words, we code the female cats as category 0 and the male cats as category 1.\n\n```python\nlabels = np.empty(40, dtype=int)\nlabels[:20] = 0\nlabels[20:] = 1\n```\n\n\n## Checking if our cats are recognized as cats\n\nAlthough MobileNetV2 has not (yet) been trained to distinguish male and female cats, it *has* been trained to recognize cats in general. Therefore, as a sanity check, let's see whether MobileNetV2 indeed categorizes all of our 40 input images as cats. We only get the top prediction for each image. (See [this previous tutorial](%link:image-classification%) if you're unsure how this works.)\n\n```python\nfrom keras.applications.mobilenet_v2 import decode_predictions\n\npredictions = model.predict(data)\nfor decoded_prediction in decode_predictions(predictions, top=1):\n    for name, desc, score in decoded_prediction:\n        print('- {} ({:.2f}%%)'.format(desc, 100 * score))\n```\n\nGreat! MobileNetV2 has recognized every image as being a cat, and has even identified specific cat breeds. The scores are fairly low, but this is because MobileNetV2 is often unsure about the exact breed, so that the scores are distributed across a few different cat breeds.\n\n\n## Modifying the model\n\nMobileNetV2 has an output layer that consists of 1000 neurons, which correspond to the 1000 categories that it has been trained on. But here we want to only classify two categories: male and female cats. Therefore, we need an output layer that consists of only two neurons.\n\nWe first create a densely connected layer that we will use as our output layer:\n\n```python\nfrom keras.layers import Dense\n\ncat_output = Dense(2, activation='softmax')\n```\n\nNext, we connect this output layer to the second-to-last layer of MobileNetV2; that is, we skip the original output layer, and connect our own output layer (`cat_output`) to the rest of the network.\n\nTo do this, we first get the output of second-to-last layer (`model.layers[-2].output`), and then call `cat_output` as if it's a function and pass this output as an argument. The return value is a special kind of object (a `KerasTensor`).\n\n```python\ncat_output = cat_output(model.layers[-2].output)\n```\n\n(Side note: Here we are using Keras's so-called [functional programming style](https://keras.io/guides/functional_api/). This is less user-friendly than the [sequential programming style](https://keras.io/guides/sequential_model/) that we used in previous tutorials, but it has the advantage of being more flexible; for example, the functional programming style allows you to construct complex, non-linear network architectures. And importantly: if you want to work with a model, such as MobileNetV2, that has been built using the functional programming style, then you have no choice but to use this style as well.)\n\nNext we create a new model, using the `Model` class. `Model()` requires two arguments: `inputs`, for which we simply use the input object from the original model; and `outputs`, which is our newly created output object. (Technically, both of these objects are `KerasTensor`s.)\n\n```python\nfrom keras import Model\n\ncat_input = model.input\ncat_model = Model(inputs=cat_input, outputs=cat_output)\n```\n\nOur `cat_model` contains 156 layers with about 2.2 million parameters. It takes a lot of time and data to train a model of this size. Fortunately, the model has already been trained for the most part, because we have simply copied all layers except for the output layer from MobileNetV2. Therefore, and to the extent that the original training is useful for our new purpose, we don't need to train these layers again, and we can *freeze* them.\n\nTo freeze a layer, simply set its `trainable` property to `False`. We do this for all layers except the last one, which is our newly created output layer.\n\n```python\nfor layer in cat_model.layers[:-1]:\n    layer.trainable = False\n```\n\nOur cat model is now ready to be compiled. (See [this previous tutorial](%link:basics%) if you're unsure how this works.)\n\n```python\ncat_model.compile(\n    optimizer='adam',\n    loss='sparse_categorical_crossentropy',\n    metrics=['accuracy']\n)\n```\n\n\n## Training the modified model\n\nOk, let's now train our cat model to distinguish male and female cats. (See [this previous tutorial](%link:basics%) if you're unsure how this works.)\n\n```python\ncat_model.fit(x=data, y=labels, epochs=20, verbose=2)\n```\n\nWow! The accuracy converges on 1, which suggests that the model is indeed able to distinguish male and female cats. This is surprising given that (to me) they look very similar.\n\nWe can verify the accuracy by generating predictions for the training data, using `np.argmax()` to decode the predictions into female (0) or male (1). (See [this previous tutorial](%link:basics%) if you're unsure how this works.)\n\n```python\npredictions = cat_model.predict(data)\nprint('Should be female (0)')\nprint(np.argmax(predictions[:20], axis=1))\nprint('Should be male (1)')\nprint(np.argmax(predictions[20:], axis=1))\n```\n\n100% accurate! Does this mean that our cat model is really able to distinguish male and female cats?\n\n\n## Validating model performance with separate validation data\n\n\u2026 Not necessarily.\n\nSo far, we've only seen how well the model is able to classify images that were part of the training data. The real test is whether the model is also able to classify images that it hasn't seen before.\n\nIn other words: we need a separate dataset for validation. One way to do this is by splitting the original data into two sets, one consisting of training data (30 images) and one consisting of validation data (10 images). And we then test how well the model is able to classify the validation data after having been trained only on the training data.\n\nLet's first create two new datasets, `training_data` and `validation_data`, as well as their corresponding labels, `training_labels` and `validation_labels`.\n\n\n```python\n# The first 15 images for male and female cats will be used for training\ntraining_data = np.empty((30, 224, 224, 3))\ntraining_data[:15] = data[:15]\ntraining_data[15:] = data[20:35]\ntraining_labels = np.empty(30)\ntraining_labels[:15] = 0\ntraining_labels[15:] = 1\n# The last 5 images for male and female cats will be used for validation\nvalidation_data = np.empty((10, 224, 224, 3))\nvalidation_data[:5] = data[15:20]\nvalidation_data[5:] = data[35:]\nvalidation_labels = np.empty(10)\nvalidation_labels[:5] = 0\nvalidation_labels[5:] = 1\n```\n\nWe create a fresh cat model (`cat_model2`) that is identical to our previous cat model, except that we haven't retrained it yet.\n\n```python\ncat_output2 = Dense(2, activation='softmax')\ncat_output2 = cat_output2(model.layers[-2].output)\ncat_input2 = model.input\ncat_model2 = Model(inputs=cat_input2, outputs=cat_output2)\nfor layer in cat_model2.layers[:-1]:\n    layer.trainable = False\ncat_model2.compile(\n    optimizer='adam',\n    loss='sparse_categorical_crossentropy',\n    metrics=['accuracy']\n)\n```\n\nWe then retrain our fresh cat model, just as before, except that this time we use the `validation_data` keyword to pass our validation data and labels as a `tuple`.\n\n```python\ncat_model2.fit(\n    x=training_data,\n    y=training_labels,\n    validation_data=(validation_data, validation_labels),\n    epochs=20,\n    verbose=2\n)\n```\n\nAs before, the (regular) accuracy goes up to 1. But crucially, the validation accuracy does not! This means that our model never really learned to distinguish male and female cats; it merely learned to recognize all of the exemplars that we trained it on, without being able to generalize this knowledge to new cats. This is called *overfitting* and often happens when a network is trained with a small dataset and/ or on a difficult task. (Both of which are true here.)\n\nIt's just really hard to tell apart male cat from female cats. That's also what Chris Longmore concluded.\n\n\n## Video tutorial\n\n%--\nvideo:\n    id: VidTutorial\n    source: youtube\n    videoid: 8LjK4knsTRQ\n    caption: Watch this tutorial on YouTube!\n--%",
    "title": "Customizing MobileNetV2 through transfer learning",
    "url": "https://pythontutorials.eu/deep-learning/transfer-learning",
    "path": "content/pages/deep-learning/transfer-learning.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Introduction to deep learning\n\ntitle: Introduction to deep learning\nnext_title: Building a basic neural network\nnext_url: %url:basics%\n\n\n[TOC]\n\n\n## About this course\n\nIn this course, which consists of four chapters, you will learn to work with artificial neural networks using [Keras](https://keras.io/), a Python library for deep learning. You will learn how to build and train a small neural network from scratch, how to use large, pretrained neural networks, and how to modify pretrained networks for your own purpose.\n\nBut before we dive into the code, let's introduce the basic concepts and terminology of deep learning!\n\n\n%--\nfigure:\n id: FigOctopus\n source: octopus-teacher.png\n caption: Your mysterious octopus teacher\n--%\n\n\n## Concepts and terminology\n\n### Artificial neural networks\n\nBrains are biological neural networks. A brain consists of about 100 billion brain cells, or *neurons*, which are connected to each other through about 100 trillion *synapses*. When a neuron becomes active, it sends a signal to all other neurons to which it is connected. In response, some of these other neurons become active themselves and send signals to yet other neurons. And so on, in a cascade of neural activity that, in a way that neuroscientists are only just beginning to understand (but still don't, really), gives rise to feelings and thoughts.\n\nAn *artificial neural network* is a computer program that is inspired by biological neural networks. Artifical neural networks also consist of neurons (sometimes called *nodes* in this context) that are connected to each other. But artificial neurons and connections are software rather than cells.\n\n\n%--\nfigure:\n    source: perceptron.png\n    id: FigPerceptron\n    caption: |\n        A simple artificial neural network consisting of three layers. We will build and train this network in the next tutorial.\n--%\n\n\n### Deep learning\n\nA neural network consists of layers of neurons. A network is considered 'deep' when it consists of many layers. The term *deep learning* simply refers to the training of such deep networks.\n\nIn [the next tutorial](%link:basics%) we will implement a shallow network, consisting of only three layers (as shown above in %FigPerceptron). In subsequent tutorials we will work with a pretrained network (MobileNet v2) that consists of 157 layers. That's a real deep neural network!\n\n\n### Convolutional neural networks\n\nThere are many different kinds of layers that can be used in a neural network: dense layers, maxpooling layers, etc.\n\nA convolutional layer is a particular kind of layer in which each neuron is only connected to a subset of neurons in the layer above. Convolutional layers are a way to mimic the concept of so-called [receptive fields](https://en.wikipedia.org/wiki/Receptive_field) in biological neurons. Convolutional layers also reduce the number of connections (and thus the complexity) of neural networks as compared to densely connected layers, in which each neuron is connected to all neurons in the layer above.\n\n\n%--\nfigure:\n    source: Typical_cnn.png\n    id: FigCNN\n    caption: |\n        A typical convolutional neural network consists of many different kinds of layers, including at least one convolutional layer.\n        ([Source](https://commons.wikimedia.org/wiki/File:Typical_cnn.png). license: CC-by SA 4.0)\n--%\n\nA convolutional neural network (CNN) is simply a network that contains at least one convolutional layer. Most deep neural networks contain convolutional layers (as well as many other kinds of layers), which is why the terms deep neural learning and convolutional neural networks are often used interchangeably, even though they refer to different aspects of a network's architecture.\n\n\n### How comparable in size are deep neural networks to the human brain?\n\nCurrently, even the most complex neural networks are smaller than human brains. VGG19, the biggest network that is available as a pre-trained net in Keras (the Python library that we will use for these tutorials) consists of about 140 million parameters, where this number corresponds to the sum of the number of neurons and the number of connections in the network. If we make the simplifying (and almost certainly incorrect) assumption that synapses and neurons in biological brains can similarly thought of as single parameters, then VGG19 is still a million times smaller than the human brain, although it does come close in size to an insect brain.\n\nAt the time of writing (June 2022), the largest neural networks are so-called Large Language Models, such as OpenAI's [GPT-3](https://openai.com/blog/gpt-3-apps/) and Google's [PaLM](https://ai.googleblog.com/2022/04/pathways-language-model-palm-scaling-to.html). These networks, which have been trained for text prediction (whereas we will focus on image classification), have hundreds of billions of parameters, thus\u2014again making the simplifying assumption that synapses and neurons can be thought of as single parameters!\u2014coming closer to the size of a human brain.\n\n\n## Deep learning in Python\n\n### TensorFlow\n\n[TensorFlow](https://www.tensorflow.org/) is a Python library for numerical computing that has been built with deep learning (and other kinds of machine learning) in mind. Specifically, TensorFlow can make use of GPUs (the processors on your graphics card) to speed up computations. And TensorFlow has built-in functionality for differential calculus, the branch of mathematics that underlies the training of neural networks.\n\nYou can think of TensorFlow as NumPy for deep learning. We won't use TensorFlow directly though. Instead, we'll use Keras, which provides a more user-friendly and high-level interface to TensorFlow.\n\n\n### Keras\n\n[Keras](https://keras.io/) is a high-level API for deep learning. Keras is built on top of TensorFlow, and provides classes and functions that make it really easy to work with neural networks. \n\n\n## Course overview\n\nNow let's get started! This course consists of four chapters. Each chapter builds on the previous chapters, so it is recommended to follow the chapters in order!\n\n1. Introduction to deep learning (this chapter)\n2. [Building a basic neural network](%link:basics%)\n3. [Classifying images with MobileNetV2](%link:image-classification%)\n4. [Customizing MobileNetV2 through transfer learning](%link:transfer-learning%)\n\n\n## Video tutorial\n\n%--\nvideo:\n    id: VidTutorial\n    source: youtube\n    videoid: rmNTqYGpr6Y\n    caption: Watch this tutorial on YouTube!\n--%",
    "title": "Introduction to deep learning",
    "url": "https://pythontutorials.eu/deep-learning/introduction",
    "path": "content/pages/deep-learning/introduction.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Building a basic neural network\n\ntitle: Building a basic neural network\nnext_title: Classifying images\nnext_url: %url:image-classification%\n\n\n[TOC]\n\n\n## A simple task for a simple model\n\nOur first artificial neural network will be simple, and it therefore needs a simple task to be trained on. We will train it to classify numbers between 0 and 1 as being either less than 0.5 (category 0) or equal to, or higher than, 0.5 (category 1). Phrased differently, we're going to teach the network to round numbers between 0 and 1.\n\n\n## Generating the data\n\nWe first generate an array of 10,000 random numbers (between 0 and 1), which we will use as the training data (or: input) for the model; that is, each training observation consists of a single number. \n\n`np.random.random(10000)` returns a one-dimensional array of shape `(10000,)`. However, we need a two-dimensional array for our model. Specifically, the first axis should correspond to the individual observations, and should therefore be of length 10,000. The second axis should correspond to the values from each individual observation, and should therefore be of length 1. We can accomplish this by explicitly changing the shape of `data` to `(10000, 1)`.\n\n```python\nimport numpy as np\n\ndata = np.random.random(10000)\ndata.shape = 10000, 1\nprint(data[:5])  # Look at the first five observations\n```\n\nNext, we check which numbers in the training data are larger than, or equal to, 0.5. This results in an array of boolean values (`True` or `False`), which we turn into an array of `int` (`1` or `0`) values. This array will serve as the labels (or: expected output) for our model.\n\n```python\nlabels = np.array(data >= .5, dtype=int)\nprint(labels[:5])  # Look at the first five labels\n```\n\n\n## Building a simple model\n\nThe [`Sequential` model class](https://keras.io/guides/sequential_model/) allows you to specify a model's architecture as a `list` (or: sequence, hence the name) of layers. We specify two layers, both of which are `Dense`, which means that each neuron in the layer is connected to all neurons in the layer above.\n\n\nThe first (non-input) layer, which consists of 8 neurons, specifies the shape of the input observations, which in our case is only a single number (i.e., an array of shape `(1, )`). The `activation` keyword specifies how the neurons translate their input to an output. Here we use the rectified-linear-unit function ('relu'), which essentially means that neurons cannot have a negative output.\n\nThe second layer, which consists of two neurons, is our output layer. The 'softmax' activation function essentially means that the neuron's output is squashed into the 0 - 1 range.\n\n%--\nfigure:\n    source: perceptron.png\n    id: FigPerceptron\n    caption: |\n        Our network consists of an input layer, a hidden layer, and an output layer.\n--%\n\nIt is common to think of the input as a layer as well, even though it is not specified as such in Keras. We can therefore think of our model as a three-layer network, with one input layer (consisting of one neuron), one hidden layer (consisting of eight neurons), and one output layer (consisting of two neurons). A layer is referred to as 'hidden' if it's neither an input layer nor an output layer.\n\n\n```python\nfrom keras import Sequential\nfrom keras.layers import Dense\n\nmodel = Sequential([\n    Dense(units=8, input_shape=(1,), activation='relu'),\n    Dense(units=2, activation='softmax'),\n])\n```\n\nNext, we compile the model so that it's ready to be trained. In doing so, we need to specify three things.\n\nThe `optimizer` keyword specifies the algorithm that will be used to adjust the weights in the model. We will use [Adam](https://keras.io/api/optimizers/adam/), but other algorithms are available as well, and the choice of one algorithm over another is largely one of preference and experience.\n\nThe `loss` keyword specifies the loss function, which is the algorithm that determines how wrong the model's predictions are. The goal of training is to reduce the loss. We will use [sparse categorical crossentropy](https://keras.io/api/losses/probabilistic_losses/), which assumes that label values of 0 mean that the first neuron in the output layer should be the most active, whereas label values of 1 mean that the second neuron should be the most active.\n\nThe `accuracy` keyword specifies a metric that is printed during training so that you have some idea of how well the model is performing. This is just for visualization and doesn't affect the training process itself.\n\n```python\nmodel.compile(\n    optimizer='adam',\n    loss='sparse_categorical_crossentropy',\n    metrics=['accuracy']\n)\n```\n\nNow let's look at the model summary:\n\n\n```python\nmodel.summary()\n```\n\nOur model has 34 parameters, which correspond to all the weights of the connections between the neurons, as well as the bias parameter for each neuron (a kind of baseline level of activity that a neuron has in the absence of any input). \n\nThe first layer consists of eight neurons, which each have one connection to the input neuron plus one bias, so 8 \u00d7 (1 + 1) = 16 parameters in total. The second layer consists of two neurons, which each have one connection all eight neurons in the preceding layer plus one bias, so 2 \u00d7 (8 + 1) = 18 parameters in total.\n\n\n## Training the model\n\nTo train the model, we simply call the `fit()` function. During training, the model's 34 parameters are adjusted to minimize the loss.\n\nThe `epochs` keyword specifies how often the training data should be used to fit the model. In our case, we specify 10 epochs, which is similar to calling `fit()` 10 times in a row with the same data and labels.\n\nThe `verbose` keyword specifies how much information should be printed out during training.\n\n```python\nmodel.fit(x=data, y=labels, epochs=10, verbose=2)\n```\n\nAs you can see, during training, the loss goes down while the accuracy goes up until it reaches almost 100%. This means that the model has learned our simple task!\n\n\n## Testing the model\n\nThe true test of our model's performance is whether it is able to classify numbers that it wasn't trained on. In our case, we trained the model on no less than 10,000 randomly selected numbers, which means that our model has seen pretty much every number there is to see in the 0 - 1 range. Nevertheless, it is good practice to create a separate test set. So let's create a new array consisting of ten numbers:\n\n\n```python\ntest_set = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n```\n\nNow let's look at the model's predictions for our test set:\n\n```python\npredictions = model.predict(test_set)\nprint(predictions)\n```\n\nWhat are we looking at here? The predictions are a 10 by 2 array, where the first axis corresponds to each of our ten test observations, and the second axis refers to the activity of the two neurons in the output layer.\n\nThe predictions are easier to interpret if we look at which of the two neurons was most active for each of the ten test observations. We can do this using `np.argmax()` which returns the index of the highest element in the array.\n\n```python\nprint(np.argmax(predictions, axis=1))\n```\n\nNow we can easily tell that for the first five test observations (0, 0.1, 0.2, 0.3, 0.4), the first output neuron (0) was most active. This means that the network correctly classified these numbers as being less than 0.5. For the last five test observations (0.5, 0.6, 0.7, 0.8, 0.9), the second output neuron (1) was most active. This again means that the network correctly classified these numbers, this time as being equal to, or larger than, 0.5.\n\n\n## Validating the model during training\n\nAs mentioned above, it's important to verify a model's predictions using data that the model wasn't actually trained on. This is important because models are prone to *overfitting*, which occurs when a model has learned the specifics of the training data but is still unable to make (correct) predictions for new observations.\n\nWe will look at this in more detail in [a later tutorial](%link:transfer-learning%), but for now let's introduce the concept of *validation data*. By specifying the `validation_split` keyword, we can tell the model to set apart some of the data (10% in the example blow) as validation data. This data will not be used for training, and you will see a separate accuracy metric (`val_accuracy`) for this subset of the data.\n\nWe need to start with a fresh, untrained model. So let's first create a new model, copying the code above:\n\n```python\nmodel = Sequential([\n    Dense(units=8, input_shape=(1,), activation='relu'),\n    Dense(units=2, activation='softmax'),\n])\nmodel.compile(\n    optimizer='adam',\n    loss='sparse_categorical_crossentropy',\n    metrics=['accuracy']\n)\n```\n\nAnd now train our fresh model, this time setting 10% of the data apart for validation!\n\n```python\nmodel.fit(x=data, y=labels, epochs=10, verbose=2, validation_split=.1)\n```\n\nIn this case, the validation accuracy is just as high as the regular accuracy, which means that our model does not suffer from overfitting!\n\n\n## Video tutorial\n\n%--\nvideo:\n    id: VidTutorial\n    source: youtube\n    videoid: XBc3kbel7XY\n    caption: Watch this tutorial on YouTube!\n--%",
    "title": "Building a basic neural network",
    "url": "https://pythontutorials.eu/deep-learning/basics",
    "path": "content/pages/deep-learning/basics.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  },
  {
    "content": "# Classifying images with MobileNetV2\n\ntitle: Classifying images with MobileNetV2\nnext_title: Transfer learning\nnext_url: %url:transfer-learning%\n\n[TOC]\n\n\n## MobileNetV2\n\nKeras includes a number of pretrained networks ('applications') that you can download and use straight away. One of these is [MobileNetV2](https://keras.io/api/applications/mobilenet/), which has been trained to classify images.\n\nYou can simply import `MobileNetV2` from `keras.applications` and create an instance of it. The first time that you do this, the network will be downloaded from the internet.\n\nIf you don't pass any keywords to `MobileNetV2()`, then the network will have random weights; that is, you will get the architecture of the network, but not the weights, and you will therefore have to train it yourself. By specifying `weights='imagenet'`, you indicate that you want the network to be pretrained.\n\n```python\nfrom keras.applications.mobilenet_v2 import MobileNetV2\n\nmodel = MobileNetV2(weights='imagenet')\n# model.summary()  # Uncomment this to print a long summary!\n```\n\n\n## Preparing an image for model input\n\nWe're going to ask MobileNetV2 to which category the following image belongs:\n\n%--\nfigure:\n    source: boef.jpg\n    id: FigBoef\n    caption: |\n        The Boef on her birthday.\n--%\n\nThis is a photo of The Boef when she was celebrating her birthday at my mother's place, where it seems that things escalated. The Boef is a bunny, but to a naive observer this may not be obvious. So it's interesting to see what MobileNetV2 sees in this photo.\n\nNeural networks are picky when it comes to the kind of input that they expect. If you provide input in a format that the network doesn't expect, then the predictions won't make sense (if the structure of the input is superficially compatible with the network) or the code will simply crash (if the structure of the input is incompatible).\n\nMobileNetV2 expects images of 224 \u00d7 224 pixels with three color channels. In other words, it expects input of shape `(224, 224, 3)`. You can pass multiple images at once to the model, just like we passed multiple numbers to our model in [the previous tutorial](%link:basics%). This means that the input should actually consist of four dimensions, where the first dimension corresponds to the index of the image.\n\nHere we only pass a single image to the model, which means that the first dimension of the input is of size 1.\n\n```python\nimport numpy as np\nfrom imageio import imread\n\ndata = np.empty((1, 224, 224, 3))\ndata[0] = imread('data/boef.jpg')\n```\n\nWhen you load an image with `imread()`, the pixel values are in the 0 - 255 range. However, MobileNetV2 expects pixel values to be in the -1 to 1 range. You could perform this transformation yourself, but Keras also provides preprocessing functions:\n\n```python\nfrom keras.applications.mobilenet_v2 import preprocess_input\n\ndata = preprocess_input(data)\n```\n\n\n## Classifying an image\n\nNow that our image is in the correct format for MobileNetV2, we can get the predictions. (See [this previous tutorial](%link:basics%) if you're unsure how this works.)\n\n```python\npredictions = model.predict(data)\nprint('Shape: {}'.format(predictions.shape))\n```\n\nAs before, the predictions are returned as a two-dimensional array where the first axis corresponds to the observations (images, in this case). Since we have fed only a single image into the model, the first dimension is of size 1. The second axis corresponds to the output neurons of the model. Since MobileNetV2 has 1000 neurons in the output layer, the second dimension is of size 1000.\n\nWe can check which output neuron was most active using `np.argmax()`, which provides the index of the highest value:\n\n```python\noutput_neuron = np.argmax(predictions[0])\nprint('Most active neuron: {} ({:.2f}%)'.format(\n    output_neuron,\n    100 * predictions[0][output_neuron]\n))\n```\n\nHowever, knowing that neuron 155 became the most active in response to the image of The Boef is not, by itself, very informative, because we also need to know which category this corresponds to. Fortunately, Keras provides a function that automatically maps predictions onto scores for the corresponding categories:\n\n```python\nfrom keras.applications.mobilenet_v2 import decode_predictions\n\nfor name, desc, score in decode_predictions(predictions)[0]:\n    print('- {} ({:.2f}%%)'.format(desc, 100 * score))\n```\n\nSo MobileNetV2 is fairly confident that The Boef is a Shih-Tzu. Fair enough, MobileNetV2.\n\n%--\nfigure:\n    source: shih-tzu.png\n    id: FigShihTzu\n    caption: |\n        A Shih-Tzu.\n--%\n\n\n## Video tutorial\n\n%--\nvideo:\n    id: VidTutorial\n    source: youtube\n    videoid: w8Qx40tHeEM\n    caption: Watch this tutorial on YouTube!\n--%",
    "title": "Classifying images with MobileNetV2",
    "url": "https://pythontutorials.eu/deep-learning/image-classification",
    "path": "content/pages/deep-learning/image-classification.md",
    "topics": [
      "datamatrix"
    ],
    "collection": "datamatrix",
    "foundation": false,
    "howto": false,
    "chunk": 1,
    "total_chunks": 1
  }
]